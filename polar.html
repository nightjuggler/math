<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Polar Curve Explorer</title>
<script src="https://d3js.org/d3.v5.min.js"></script>
<style>
a {
	text-decoration: none;
}
body {
	background-color: white;
	font-family: verdana;
	font-size: 10pt;
}
table {
	border: 1px solid black;
	border-spacing: 0;
	margin-left: auto;
	margin-right: auto;
	margin-top: 2px;
}
td,th {
	border: 1px solid black;
	padding: 2px 4px 2px 4px;
	vertical-align: top;
}
th {
	background-color: rgb(220,220,220);
}
#graph {
	text-align: center;
}
#graph div {
	padding-bottom: 2px;
}
#graph svg {
	border: 1px solid black;
	margin-top: 2px;
}
circle {
	fill: none;
	stroke: black;
	stroke-opacity: 0.3;
	stroke-width: 1;
}
.axis {
	font-family: verdana;
	font-size: 10pt;
	stroke: black;
	stroke-opacity: 0.3;
	stroke-width: 1;
}
.curve {
	fill: none;
	stroke: magenta;
	stroke-width: 2;
}
.radial {
	stroke: green;
	stroke-width: 2;
}
.tangent {
	stroke: blue;
	stroke-width: 2;
}
</style>
<script>
/* globals d3, document, setTimeout, window */
(function() {
"use strict";
const mathConstants = {
	e: Math.E,
	phi: (1 + Math.sqrt(5)) / 2,
	pi: Math.PI,
};
function createSvg(width, height)
{
	const centerX = Math.floor(width / 2);
	const centerY = Math.floor(height / 2);

	const svg = d3.select("#graph")
		.append("svg")
			.attr("width", width)
			.attr("height", height)
		.append("g")
			.attr("transform", "translate(" + centerX + "," + centerY + ")");

	svg.append("line")
		.attr("class", "axis")
		.attr("x1", 0)
		.attr("y1", centerY)
		.attr("x2", 0)
		.attr("y2", -centerY);
	svg.append("line")
		.attr("class", "axis")
		.attr("x1", -centerX)
		.attr("y1", 0)
		.attr("x2", centerX)
		.attr("y2", 0);

	return svg;
}
function parseAnimate(q, v, propName)
{
	const m = v.match(/^([1-9][0-9]{0,2})?,([1-9][0-9]{1,3})?$/);
	if (m === null) return;
	const [, step, delay] = m;
	const animate = {};
	if (step) animate.step = parseInt(step, 10);
	if (delay) animate.delay = parseInt(delay, 10);
	q[propName] = animate;
}
function parseDemo(q, v)
{
	if (v.match(/^[1-9][0-9]?$/) !== null)
		q.demo = parseInt(v, 10);
}
function parseExpr(q, v, propName)
{
	if (v === "") return;
	const m = v.match(/^(-?(?:[1-9][0-9]*|0)(?:\.[0-9]+)?)?(e|phi|pi)?(?:\/([1-9][0-9]*))?$/);
	if (m === null) return;
	const [, a, b, c] = m;
	if (!(a || b)) return;
	v = a ? Number(a) : 1;
	if (b) v *= mathConstants[b];
	if (c) v /= Number(c);
	q[propName] = v;
}
function parseExprList(q, v, propList)
{
	const values = v.split(",");
	const numValues = values.length > propList.length ? propList.length : values.length;

	for (let i = 0; i < numValues; i += 1)
		parseExpr(q, values[i], propList[i]);
}
function parsePoints(q, v)
{
	if (v.match(/^[1-9][0-9]{0,5}$/) !== null)
		q.numPoints = parseInt(v, 10);
}
function isValidId(s, n)
{
	return s.length <= n && s.match(/^[a-z][_0-9a-z]*$/) !== null;
}
function parseQueryString(params, handlers, flags)
{
	const q = window.location.search;

	if (typeof q !== 'string' || q.charAt(0) !== '?') return;

	if (!flags) flags = {};
	if (!handlers) handlers = {};

	for (const s of q.substr(1).split('&'))
	{
		const i = s.indexOf('=');
		if (i < 0 && isValidId(s, 6) && flags[s]) {
			params[flags[s]] = true;
			continue;
		}
		if (i < 1 || i === s.length - 1) continue;
		const k = s.substr(0, i);
		const v = s.substr(i + 1);

		if (isValidId(k, 12) && handlers[k])
			handlers[k](params, v);
	}
}
function updateTangent(i, config, tangent, radial, textNode)
{
/*
	The slope m of the line tangent to the curve r = f(t) at point (r, t) is

	m = dy/dx = ( (dr/dt)*sin(t) + r*cos(t) ) / ( (dr/dt)*cos(t) - r*sin(t) )
*/
	const {derivative, radius, theta} = config;

	const drdt = derivative(i);
	const r = radius(i);
	const sin = Math.sin(theta(i));
	const cos = Math.cos(theta(i));
	const x = r * cos;
	const y = r * sin;
	const m = (drdt * sin + x) / (drdt * cos - y);
/*
	The tangent of the slope angle a of the tangent line is the slope m: tan(a) = m

	To move a distance h along the tangent line, calculate dx and dy:

	dx = h * cos(a) = h / sqrt(1 + tan(a)*tan(a)) = h / sqrt(1 + m*m)
	dy = h * sin(a) = h * tan(a) / sqrt(1 + tan(a)*tan(a)) = tan(a) * dx = m * dx
*/
	const h = 200;
	const dx = h / Math.sqrt(1 + m * m);
	const dy = m * dx;

	tangent.attr("x1", x + dx).attr("y1", -(y + dy)).attr("x2", x - dx).attr("y2", -(y - dy));
	radial.attr("x2", x).attr("y2", -y);
/*
	The tangent of the tangent angle psi of the curve r = f(t) at point (r, t) is

	tan(psi) = r / (dr/dt)

	The tangent angle is the angle between the radial line from the origin to the point (r, t)
	and the line tangent to the curve at point (r, t).

	The slope angle of the curve at point (r, t) is pi/2 - psi
*/
	if (textNode) {
		const tangentAngle = Math.atan2(r, drdt) * 180 / Math.PI;
		const slopeAngle = 90 - tangentAngle;
		textNode.nodeValue = "slope angle = " + slopeAngle.toFixed(2) + " degrees, " +
			"tangent angle = " + tangentAngle.toFixed(2) + " degrees";
	}
}
function setAngle(config)
{
	let {thetaStart, thetaEnd, thetaStep, numPoints} = config;

	if (typeof thetaStart !== "number")
		thetaStart = 0;

	if (typeof thetaEnd === "number" && thetaStart < thetaEnd) {
		if (typeof thetaStep === "number" && thetaStep > 0)
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		else if (typeof numPoints === "number" && numPoints > 1)
			thetaStep = (thetaEnd - thetaStart) / (numPoints - 1);
		else {
			thetaStep = Math.PI / 180; // 1 degree;
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		}
	} else {
		if (!(typeof thetaStep === "number" && thetaStep > 0))
			thetaStep = Math.PI / 180; // 1 degree;
		if (!(typeof numPoints === "number" && numPoints > 1))
			numPoints = 12*360 + 1;
	}

	const thetaAdjust = Math.PI / 2 - thetaStart;
	config.angle = i => thetaAdjust - i * thetaStep;
	config.theta = i => thetaStart + i * thetaStep;

	config.thetaStart = thetaStart;
	config.thetaStep = thetaStep;
	config.numPoints = numPoints;

	return config.theta;
}
function logSpiral(config)
{
	const theta = setAngle(config);

	let {initialRadius, slopeAngle, tangentAngle, growthFactor, growthAngle} = config;

	if (!(typeof initialRadius === "number" && initialRadius !== 0))
		initialRadius = 40;
	if (!(typeof growthFactor === "number" && growthFactor > 0))
		growthFactor = 1.5;
	if (!(typeof growthAngle === "number" && growthAngle > 0))
		growthAngle = Math.PI; // 180 degrees

	if (typeof slopeAngle === "number") {
		// tangentAngle = math.PI / 2 - slopeAngle;

		const k = Math.tan(slopeAngle);
		const radius = i => initialRadius * Math.exp(k * theta(i));
		config.radius = radius;
		config.derivative = i => k * radius(i);
		growthFactor = Math.exp(k * growthAngle);

	} else if (typeof tangentAngle === "number" && tangentAngle !== 0) {

		const k = 1 / Math.tan(tangentAngle);
		const radius = i => initialRadius * Math.exp(k * theta(i));
		config.radius = radius;
		config.derivative = i => k * radius(i);
		growthFactor = Math.exp(k * growthAngle);

	} else {
		const k = Math.log(growthFactor) / growthAngle;
		const radius = i => initialRadius * Math.pow(growthFactor, theta(i) / growthAngle);
		config.radius = radius;
		config.derivative = i => k * radius(i);
	}

	config.grid = function(svg) {
		for (let i = 0; i < 6; i += 1)
			svg.append("circle")
				.attr("cx", 0)
				.attr("cy", 0)
				.attr("r", initialRadius * Math.pow(growthFactor, i));
	};
	return config;
}
function roseCurve(config)
{
	const theta = setAngle(config);

	let {scale, k, offset} = config;

	if (!(typeof scale === "number" && scale > 0))
		scale = 200;
	if (typeof k !== "number")
		k = 4 / 9;
	if (typeof offset !== "number")
		offset = 0;

	config.radius = i => scale * Math.cos(k * theta(i)) + offset;
	config.derivative = i => scale * k * -Math.sin(k * theta(i));

	config.grid = function(svg) {
		svg.append("circle")
			.attr("cx", 0)
			.attr("cy", 0)
			.attr("r", scale);
	};
	return config;
}
function spiral(config)
{
	const theta = setAngle(config);

	let {a, b, c} = config;

	if (typeof a !== "number") a = 0;
	if (typeof b !== "number") b = 12;
	if (typeof c !== "number" || c === 0) c = 1;

	if (c === 1) {
		config.radius = i => a + b * theta(i);
		config.derivative = i => b;
	} else {
		config.radius = i => a + b * Math.pow(theta(i), 1 / c);
		config.derivative = i => b * Math.pow(theta(i), 1 / c - 1) / c;
	}
	return config;
}
function predefinedConfig(i)
{
	const growthFactor = mathConstants.phi;
	const growthAngle = 2 * Math.PI;
	const configs = [
		logSpiral({
			slopeAngle: Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		}),
		logSpiral({
			tangentAngle: Math.PI / 2 - Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		}),
	];
	return configs[i < configs.length ? i : 0];
}
function main()
{
	let config = {};
	parseQueryString(config, {
		anim: function(q, v) {
			parseAnimate(q, v, "animate");
		},
		animtan: function(q, v) {
			parseAnimate(q, v, "animateTangent");
		},
		demo: parseDemo,
		logspiral: function(q, v) {
			q.curve = logSpiral;
			parseExprList(q, v, ["initialRadius", "slopeAngle", "tangentAngle",
				"growthFactor", "growthAngle"]);
		},
		points: parsePoints,
		rose: function(q, v) {
			q.curve = roseCurve;
			parseExprList(q, v, ["scale", "k", "offset"]);
		},
		spiral: function(q, v) {
			q.curve = spiral;
			parseExprList(q, v, ["a", "b", "c"]);
		},
		theta: function(q, v) {
			parseExprList(q, v, ["thetaStart", "thetaEnd", "thetaStep"]);
		},
	}, {});

	if (config.demo)
		config = predefinedConfig(config.demo - 1);
	else
		config = (config.curve || roseCurve)(config);

	const {numPoints, angle, radius} = config;
	const data = Array.from({length: numPoints}, (v, i) => [angle(i), radius(i)]);

	const svg = createSvg(900, 680);
	if (config.grid)
		config.grid(svg);

	const d3line = d3.lineRadial();
	const path = svg.append("path").attr("class", "curve");

	if (config.animate) {
		let i = 0;
		const {step = 8, delay = 50} = config.animate;
		const update = function() {
			i += step;
			path.attr("d", d3line(data.slice(0, i)));
			if (i < numPoints)
				setTimeout(update, delay);
		};
		update();
	} else {
		path.attr("d", d3line(data));
	}

	if (config.derivative && config.animateTangent) {
		const tangent = svg.append("line").attr("class", "tangent");
		const radial = svg.append("line").attr("class", "radial");
		const textNode = document.getElementById("textnode").firstChild;

		let i = 0;
		const n = numPoints - 1;
		const {step = 4, delay = 100} = config.animateTangent;
		const update = function() {
			updateTangent(i, config, tangent, radial, textNode);
			if (i < n) {
				i += step;
				if (i > n) i = n;
				setTimeout(update, delay);
			}
		};
		update();
	}
}
window.addEventListener("DOMContentLoaded", main);
})();
</script>
</head>
<body>
<div id="graph">
<div id="textnode">&nbsp;</div>
</div>
<table>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Logarithmic_spiral">Logarithmic Spirals</a></th></tr>
<tr>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi">r = phi^(theta/(2pi))</a></td>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&anim=,">O</a>
/   <a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>growthFactor = phi, growthAngle = 2pi</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi">r = e^(tan(6pi/180)*theta)</a></td>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi&anim=,">O</a>
/   <a href="polar.html?logspiral=,6pi/180&theta=,8pi&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>slopeAngle = 6&deg;</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi">r = e^(theta/tan(84pi/180))</a></td>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi&anim=,">O</a>
/   <a href="polar.html?logspiral=,,84pi/180&theta=,8pi&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>tangentAngle = 84&deg;</td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Rose_(mathematics)">Roses</a></th></tr>
<tr>
<td><a href="polar.html?rose=,4/9&theta=,32pi,0.5pi/180">r = cos(4/9*theta)</a></td>
<td><a href="polar.html?rose=,4/9&theta=,32pi,0.5pi/180&anim=32,">O</a>
/   <a href="polar.html?rose=,4/9&theta=,32pi,0.5pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 0.5&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,5,60&theta=,32pi,0.5pi/180">r = cos(5*theta) + 60</a></td>
<td><a href="polar.html?rose=,5,60&theta=,32pi,0.5pi/180&anim=,">O</a>
/   <a href="polar.html?rose=,5,60&theta=,32pi,0.5pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 0.5&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,pi&theta=,32pi,0.5pi/180">r = cos(pi*theta)</a></td>
<td><a href="polar.html?rose=,pi&theta=,32pi,0.5pi/180&anim=16,20">O</a>
/   <a href="polar.html?rose=,pi&theta=,32pi,0.5pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 0.5&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,e&theta=,32pi,0.5pi/180">r = cos(e*theta)</a></td>
<td><a href="polar.html?rose=,e&theta=,32pi,0.5pi/180&anim=16,20">O</a>
/   <a href="polar.html?rose=,e&theta=,32pi,0.5pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 0.5&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=200,1,100&theta=,2pi">r = 200*cos(theta) + 100</a></td>
<td><a href="polar.html?rose=200,1,100&theta=,2pi&anim=,">O</a>
/   <a href="polar.html?rose=200,1,100&theta=,2pi&animtan=,">X</a></td>
<td>0 - 2pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lima%C3%A7on">Lima&ccedil;on</a></td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Archimedean_spiral">Archimedean Spirals</a></th></tr>
<tr>
<td><a href="polar.html?spiral=,12&theta=,8pi">r = 12*theta</a></td>
<td><a href="polar.html?spiral=,12&theta=,8pi&anim=,">O</a>
/   <a href="polar.html?spiral=,12&theta=,8pi&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><a href="polar.html?spiral=,40,2&theta=,16pi">r = 40*sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,40,2&theta=,16pi&anim=,">O</a>
/   <a href="polar.html?spiral=,40,2&theta=,16pi&animtan=,50">X</a></td>
<td>0 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Fermat's_spiral">Fermat's spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi">r = 400/theta</a></td>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&anim=,">O</a>
/   <a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&animtan=,">X</a></td>
<td>pi/4 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Hyperbolic_spiral">Hyperbolic spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi">r = 240/sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&anim=,">O</a>
/   <a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&animtan=,">X</a></td>
<td>pi/12 - 32pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lituus_(mathematics)">Lituus</a></td>
</tr>
</table>
</body>
</html>
