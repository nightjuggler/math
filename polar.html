<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Polar Curve Explorer</title>
<style>
a {
	text-decoration: none;
}
body {
	background-color: white;
	font-family: verdana;
	font-size: 10pt;
	margin-left: 0;

	-webkit-text-size-adjust: none;
	text-size-adjust: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}
td,th {
	padding: 2px 6px;
	vertical-align: top;
}
th {
	background-color: rgb(220,220,220);
}
#graph svg {
	border: 1px solid black;
	touch-action: manipulation;
}
#params {
	width: 220px;
}
#params td:first-child {
	padding-right: 0;
	text-align: right;
	width: 120px;
}
#urlparams td {
	font-family: monaco;
	white-space: nowrap;
}
#urlparams > tbody > tr > td:first-child {
	border-right: none;
	padding-right: 0;
	text-align: right;
}
#urlparams > tbody > tr > td:nth-child(2) {
	border-left: none;
	padding-left: 0;
}
.axis {
	fill: none;
	stroke: black;
	stroke-opacity: 0.3;
	stroke-width: 1px;
}
.borderTable {
	border: 1px solid black;
}
.borderTable td,
.borderTable th {
	border: 1px solid black;
}
.curve {
	fill: none;
	stroke: url(#gradient1);
	stroke-width: 2px;
}
.morph {
	display: grid;
	grid-template-columns: repeat(3, max-content);
}
.morph div:nth-child(3n+1) {
	background-color: lavender;
	padding-right: 3px;
	text-align: right;
}
.morph div:nth-child(3n+2) {
	background-color: lavender;
	padding-left: 2px;
	padding-right: 5px;
	text-align: right;
}
.morph div:nth-child(3n) {
	background-color: lavender;
}
.radial {
	stroke: green;
	stroke-width: 2px;
}
.tangent {
	stroke: blue;
	stroke-width: 2px;
}
.tangentArc {
	fill: none;
	stroke: red;
	stroke-width: 4px;
}
</style>
<script>
/* globals document, window, clearTimeout, setTimeout */
(function() {
"use strict";
const mathConstants = {
	e: Math.E,
	phi: (1 + Math.sqrt(5)) / 2,
	pi: Math.PI,
};
const textNodes = {};
var animation;
function handleKeyDown(event)
{
	if (!animation) return true;

	switch (event.key || event.keyIdentifier) {
		case "ArrowLeft":
		case "Left":
			if (animation.timeout !== null) return true;
			animation.update(true, true);
			break;
		case "ArrowRight":
		case "Right":
			if (animation.timeout !== null) return true;
			animation.update(true);
			break;
		case "U+0020":
		case " ":
			if (animation.timeout !== null) {
				clearTimeout(animation.timeout);
				animation.timeout = null;
			} else
				animation.update();
			break;
		default:
			return true;
	}

	event.preventDefault();
	event.stopPropagation();
	return false;
}
function handleClick()
{
	if (!animation)
		return true;
	if (animation.timeout !== null) {
		clearTimeout(animation.timeout);
		animation.timeout = null;
	} else
		animation.update();
	return true;
}
function animationBegin(update)
{
	document.addEventListener("keydown", handleKeyDown);
	const svg = document.getElementById("graph").firstChild;
	svg.addEventListener("click", handleClick);
	animation = {update: update, svg: svg};
	update(false, true);
}
function animationEnd()
{
	document.removeEventListener("keydown", handleKeyDown);
	animation.svg.removeEventListener("click", handleClick);
	animation = null;
}
function createSvgElem(tagName, attributes)
{
	const svgNS = "http://www.w3.org/2000/svg";
	const element = document.createElementNS(svgNS, tagName);

	for (const [name, value] of attributes)
		element.setAttribute(name, value);

	return element;
}
function createSvg(config)
{
	let width = config.width || 900;
	let height = config.height || 680;

	if (width < 200) width = 200; else if (width > 2000) width = 2000;
	if (height < 200) height = 200; else if (height > 2000) height = 2000;

	const centerX = Math.floor(width / 2) + (config.centerX || 0);
	const centerY = Math.floor(height / 2) + (config.centerY || 0);

	const svg = document.getElementById("graph")
		.appendChild(createSvgElem("svg", [["width", width], ["height", height]]))
		.appendChild(createSvgElem("g", [["transform", "translate(" + centerX + "," + centerY + ")"]]));

	svg.appendChild(createSvgElem("line", [["class", "axis"],
		["x1", 0], ["y1", centerY],
		["x2", 0], ["y2", -centerY]]));
	svg.appendChild(createSvgElem("line", [["class", "axis"],
		["x1", -centerX], ["y1", 0],
		["x2", centerX], ["y2", 0]]));

	return svg;
}
function parseAnimate(v, config, prop)
{
	const [step, delay] = v.split(",");
	const animate = {};
	if (typeof step === "string" && /^[1-9][0-9]{0,2}$/.test(step))
		animate.step = parseInt(step, 10);
	if (typeof delay === "string" && /^[1-9][0-9]{1,3}$/.test(delay))
		animate.delay = parseInt(delay, 10);
	config[prop] = animate;
}
function parseCenter(v, config)
{
	const [x, y] = v.split(",");
	const re = /^-?[1-9][0-9]{0,3}$/;
	if (typeof x === "string" && re.test(x)) config.centerX = parseInt(x, 10);
	if (typeof y === "string" && re.test(y)) config.centerY = parseInt(y, 10);
}
function parseExpr(v)
{
	if (v === "") return null;
	let result = 0;
	for (;;) {
		const m = v.match(/^-?((?:[1-9][0-9]*|0)(?:\.[0-9]+)?)?(e|phi|pi)?(?:\/([1-9][0-9]*))?/);
		if (m === null) return null;
		const [s, a, b, c] = m;
		if (!(a || b)) return null;
		let x = a ? Number(a) : 1;
		if (b) x *= mathConstants[b];
		if (c) x /= Number(c);
		result += s.charAt(0) === "-" ? -x : x;
		v = v.substring(s.length);
		if (v.length === 0) break;
		if (v.charAt(0) === "-") continue;
		if (v.charAt(0) !== "+") return null;
		v = v.substring(1);
	}
	return result;
}
function parseExprList(v, config, props)
{
	const values = v.split(",");
	const numValues = values.length > props.length ? props.length : values.length;

	for (let i = 0; i < numValues; i += 1)
		if ((v = parseExpr(values[i])) !== null) config[props[i]] = v;
}
function parseMorph(v, config)
{
	v = v.split(",");
	if (v.length < 3) return;
	const [steps, delay, ...props] = v;
	if (/^[1-9][0-9]{0,3}$/.test(steps)) config.morphSteps = parseInt(steps, 10);
	else if (steps !== "") return;
	if (/^[1-9][0-9]{1,3}$/.test(delay)) config.morphDelay = parseInt(delay, 10);
	else if (delay !== "") return;

	const morph = [];
	for (v of props) {
		v = v.split(":");
		if (v.length !== 3) return;
		let [prop, minValue, maxValue] = v;
		if (!/^[a-z][A-Za-z]*$/.test(prop)) return;
		if ((minValue = parseExpr(minValue)) === null) return;
		if ((maxValue = parseExpr(maxValue)) === null) return;
		morph.push([prop, minValue, maxValue]);
	}
	config.morph = morph;
}
function parseNumber(v, len, config, prop)
{
	if (v.length <= len && /^[1-9][0-9]*$/.test(v))
		config[prop] = parseInt(v, 10);
}
function parseStroke(v)
{
	const m = v.match(/^(?:([A-Za-z]+)|(gradient[1-9]))?(?:,([1-9][0-9]?))?$/);
	if (m === null) return;

	let [, color, gradient, width] = m;
	if (gradient)
		color = "url(#" + gradient + ")";
	if (width)
		width += "px";

	for (const rule of document.styleSheets[0].cssRules)
		if (rule.selectorText === ".curve") {
			if (color)
				rule.style.setProperty("stroke", color);
			if (width)
				rule.style.setProperty("stroke-width", width);
			break;
		}
}
function parseQueryString(config, handlers)
{
	const q = window.location.search;

	if (typeof q !== "string" || q.charAt(0) !== "?") return;

	const validKey = (key, len) => key.length <= len && /^[a-z][0-9a-z]*$/.test(key);

	for (const s of q.substring(1).split("&"))
	{
		const i = s.indexOf("=");
		const [key, val] = i < 0 ? [s, ""] : [s.substring(0, i), s.substring(i + 1)];

		if (validKey(key, 12) && handlers.hasOwnProperty(key))
			handlers[key](val, config);
	}
}
function setTextNodes()
{
	for (const id of [
		"formula",
		"theta",
		"radius",
		"thetaStart",
		"thetaEnd",
		"thetaStep",
		"numPoints",
		"slopeAngle",
		"tangentAngle",
		"growthFactor",
		"growthAngle",
		])
		textNodes[id] = document.getElementById(id).firstChild;
}
function removeTextRow(textNode)
{
	const tr = textNode.parentNode.parentNode.parentNode;
	tr.parentNode.removeChild(tr);
}
function setFormula(formula)
{
	textNodes.formula.nodeValue = formula;
}
const regEx = /\.?0+$/;
const toStr = n => Number.isInteger(n) ? n : n.toFixed(6).replace(regEx, "");
const toStr2 = n => Number.isInteger(n) ? n : n.toFixed(2).replace(regEx, "");
const oneX = n => n === 1 ? "" : toStr(n) + " * ";
const pm0 = n => n === 0 ? "" : n < 0 ? " \u2212 " + toStr(-n) : " + " + toStr(n);
const pm1 = n => n < 0 ? " \u2212 " + oneX(-n) : " + " + oneX(n);
function spiralFormula(a, b, c)
{
	let formula = "";
	if (a !== 0) formula += toStr(a) + " + ";
	if (b !== 1) formula += toStr(b) + " * ";
	formula += "theta";
	if (c !== 1) formula += " ^ (1 / " + toStr(c) + ")";
	return formula;
}
function setRadialPath(path, data)
{
	let m = true;
	path.setAttribute("d", data.map(([t, r]) => Number.isNaN(r) ? (m = true, "") :
		(m ? (m = false, "M") : "L") +
		( r * Math.cos(t)).toFixed(2) + "," +
		(-r * Math.sin(t)).toFixed(2)).join(""));
}
function updateTangent(i, config, radial, tangent, tangentArc)
{
/*
	The slope m of the line tangent to the curve r = f(t) at point (r, t) is

	m = dy/dx = ( (dr/dt)*sin(t) + r*cos(t) ) / ( (dr/dt)*cos(t) - r*sin(t) )
*/
	const t = config.theta(i);
	const r = config.radius(t);

	textNodes.theta.nodeValue = toStr2(t * 180 / Math.PI);

	if (Number.isNaN(r)) {
		radial.removeAttribute("x2");
		radial.removeAttribute("y2");
		tangent.removeAttribute("x1");
		tangent.removeAttribute("y1");
		tangent.removeAttribute("x2");
		tangent.removeAttribute("y2");
		tangentArc.removeAttribute("d");

		textNodes.radius.nodeValue = "NaN";
		textNodes.slopeAngle.nodeValue = "NaN";
		textNodes.tangentAngle.nodeValue = "NaN";
		return;
	}

	const sin = Math.sin(t);
	const cos = Math.cos(t);
	const x = r * cos;
	const y = r * sin;

	textNodes.radius.nodeValue = toStr2(r);
	radial.setAttribute("x2", x);
	radial.setAttribute("y2", -y);

	const drdt = config.derivative(t);
	const m = (drdt * sin + x) / (drdt * cos - y);

	if (Number.isNaN(m)) {
		tangent.removeAttribute("x1");
		tangent.removeAttribute("y1");
		tangent.removeAttribute("x2");
		tangent.removeAttribute("y2");
		tangentArc.removeAttribute("d");

		textNodes.slopeAngle.nodeValue = "NaN";
		textNodes.tangentAngle.nodeValue = "NaN";
		return;
	}
/*
	The tangent of the slope angle a of the tangent line is the slope m: tan(a) = m

	To move a distance h along the tangent line, calculate dx and dy:

	dx = h * cos(a) = h / sqrt(1 + tan(a)*tan(a)) = h / sqrt(1 + m*m)
	dy = h * sin(a) = h * tan(a) / sqrt(1 + tan(a)*tan(a)) = tan(a) * dx = m * dx
*/
	const h = 200;
	const dx = h / Math.sqrt(1 + m * m);
	const dy = dx === 0 ? h : m * dx;

	tangent.setAttribute("x1", x + dx);
	tangent.setAttribute("y1", -(y + dy));
	tangent.setAttribute("x2", x - dx);
	tangent.setAttribute("y2", -(y - dy));

	const rlt0 = r < 0;
	const arcRadius = rlt0 ? -20 : 20;
	if (rlt0 ? r < arcRadius : r > arcRadius) {
		const sweep = rlt0 ? 1 : 0;
		const arcX1 = (r - arcRadius) * cos;
		const arcY1 = (r - arcRadius) * sin;
		let arcDx = arcRadius / Math.sqrt(1 + m * m);
		let arcDy = arcDx === 0 ? arcRadius : m * arcDx;

		if (rlt0 ?
			m > 0 ? drdt < 0 ? cos <= 0 : sin > 0 : drdt < 0 ? sin >  0 : cos >  0 :
			m > 0 ? drdt < 0 ? sin <= 0 : cos > 0 : drdt < 0 ? cos <= 0 : sin <= 0)
		{
			arcDy = -arcDy;
			arcDx = -arcDx;
		}
		tangentArc.setAttribute("d", ["M", arcX1, -arcY1,
			"A", arcRadius, arcRadius, 0, 0, sweep, x + arcDx, -(y + arcDy)].join(" "));
	} else
		tangentArc.setAttribute("d", "");
/*
	The tangent of the tangent angle psi of the curve r = f(t) at point (r, t) is

	tan(psi) = r / (dr/dt)

	The tangent angle is the angle between the radial line from the origin to the point (r, t)
	and the line tangent to the curve at point (r, t).

	The slope angle of the curve at point (r, t) is pi/2 - psi
*/
	const tangentAngle = Math.atan2(r, drdt) * 180 / Math.PI;

	textNodes.slopeAngle.nodeValue = toStr2(90 - tangentAngle);
	textNodes.tangentAngle.nodeValue = toStr2(tangentAngle);
}
function setAngle(config)
{
	let {thetaStart, thetaEnd, thetaStep, numPoints} = config;

	if (typeof thetaStart !== "number")
		thetaStart = 0;

	if (typeof thetaEnd === "number" && thetaStart < thetaEnd) {
		if (typeof thetaStep === "number" && thetaStep > 0)
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		else if (typeof numPoints === "number" && numPoints > 1)
			thetaStep = (thetaEnd - thetaStart) / (numPoints - 1);
		else {
			thetaStep = Math.PI / 180; // 1 degree;
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		}
		if (!Number.isInteger(numPoints)) {
			numPoints = Math.ceil(numPoints);
			thetaStep = (thetaEnd - thetaStart) / (numPoints - 1);
		}
		textNodes.thetaEnd.nodeValue = toStr2(thetaEnd * 180 / Math.PI) + "\u00B0";
	} else {
		if (!(typeof thetaStep === "number" && thetaStep > 0))
			thetaStep = Math.PI / 180; // 1 degree;
		if (!(typeof numPoints === "number" && numPoints > 1))
			numPoints = 12*360 + 1;
		textNodes.thetaEnd.nodeValue = "none";
	}

	config.theta = i => thetaStart + i * thetaStep;

	textNodes.thetaStart.nodeValue = toStr2(thetaStart * 180 / Math.PI);
	textNodes.thetaStep.nodeValue = toStr2(thetaStep * 180 / Math.PI);
	textNodes.numPoints.nodeValue = toStr2(numPoints);

	return numPoints;
}
const curveConfigs = {
logspiral: [["initialRadius", "slopeAngle", "tangentAngle", "growthFactor", "growthAngle"],
function(config)
{
	let {initialRadius, slopeAngle, tangentAngle, growthFactor, growthAngle} = config;

	if (!(typeof initialRadius === "number" && initialRadius !== 0))
		initialRadius = 40;
	if (!(typeof growthFactor === "number" && growthFactor > 0))
		growthFactor = 1.5;
	if (!(typeof growthAngle === "number" && growthAngle > 0))
		growthAngle = Math.PI; // 180 degrees

	if (typeof slopeAngle === "number") {

		const k = Math.tan(slopeAngle);
		const radius = t => initialRadius * Math.exp(k * t);
		config.radius = radius;
		config.derivative = t => k * radius(t);
		setFormula(oneX(initialRadius) + "e ^ (theta * tan(" + toStr(slopeAngle) + "))");
		growthFactor = Math.exp(k * growthAngle);
		tangentAngle = Math.PI / 2 - slopeAngle;

	} else if (typeof tangentAngle === "number" && tangentAngle !== 0) {

		const k = 1 / Math.tan(tangentAngle);
		const radius = t => initialRadius * Math.exp(k * t);
		config.radius = radius;
		config.derivative = t => k * radius(t);
		setFormula(oneX(initialRadius) + "e ^ (theta / tan(" + toStr(tangentAngle) + "))");
		growthFactor = Math.exp(k * growthAngle);
		slopeAngle = Math.PI / 2 - tangentAngle;

	} else {
		const k = Math.log(growthFactor) / growthAngle;
		const radius = t => initialRadius * Math.pow(growthFactor, t / growthAngle);
		config.radius = radius;
		config.derivative = t => k * radius(t);
		setFormula(oneX(initialRadius) + toStr(growthFactor) + " ^ (theta / " + toStr(growthAngle) + ")");
		slopeAngle = Math.atan2(Math.log(growthFactor), growthAngle);
		tangentAngle = Math.PI / 2 - slopeAngle;
	}

	textNodes.slopeAngle.nodeValue = toStr2(slopeAngle * 180 / Math.PI);
	textNodes.tangentAngle.nodeValue = toStr2(tangentAngle * 180 / Math.PI);
	textNodes.growthFactor.nodeValue = toStr(growthFactor);
	textNodes.growthAngle.nodeValue = toStr2(growthAngle * 180 / Math.PI);

	config.grid = function(svg) {
		for (let i = 0; i < 6; i += 1)
			svg.appendChild(createSvgElem("circle", [["class", "axis"], ["cx", 0], ["cy", 0],
				["r", initialRadius * Math.pow(growthFactor, i)]]));
	};
	return config;
}],
rose: [["scale", "k", "offset"],
function(config)
{
	let {scale, k, offset} = config;

	if (!(typeof scale === "number" && scale > 0))
		scale = 200;
	if (typeof k !== "number")
		k = 4 / 9;
	if (typeof offset !== "number")
		offset = 0;

	config.radius = t => scale * Math.cos(k * t) + offset;
	config.derivative = t => scale * k * -Math.sin(k * t);
	setFormula(oneX(scale) + "cos(" + oneX(k) + "theta)" + pm0(offset));

	config.grid = function(svg) {
		svg.appendChild(createSvgElem("circle", [["class", "axis"], ["cx", 0], ["cy", 0], ["r", scale]]));
	};
	return config;
}],
spiral: [["a", "b", "c"],
function(config)
{
	let {a, b, c} = config;
	if (typeof a !== "number") a = 0;
	if (typeof b !== "number") b = 12;
	if (typeof c !== "number" || c === 0) c = 1;

	if (c === 1) {
		config.radius = t => a + b * t;
		config.derivative = () => b;
	} else {
		config.radius = t => a + b * Math.pow(t, 1 / c);
		config.derivative = t => b * Math.pow(t, 1 / c - 1) / c;
	}
	setFormula(spiralFormula(a, b, c));
	return config;
}],
sinspiral: [["a", "n", "b"],
function(config)
{
	let {a, n, b} = config;
	if (typeof a !== "number") a = 1;
	if (typeof n !== "number" || n === 0) n = 1;
	if (typeof b !== "number") b = 0;

	config.radius = t => a * Math.pow(Math.cos(n * t), 1 / n) + b;
	config.derivative = t => -a * Math.sin(n * t) * Math.pow(Math.cos(n * t), 1 / n - 1);

	const nStr = toStr(n);
	setFormula(oneX(a) + "cos(" + nStr + " * theta) ^ (1 / " + nStr + ")" + pm0(b));
	return config;
}],
"a*sin(b*t)*t+c": [["a", "b", "c"],
function(config)
{
	let {a, b, c} = config;
	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 0;

	config.radius = t => a * Math.sin(b * t) * t + c;
	config.derivative = t => a * (Math.cos(b * t) * b * t + Math.sin(b * t));

	setFormula(oneX(a) + "sin(" + oneX(b) + "theta) * theta" + pm0(c));
	return config;
}],
"a*sin(b*t)/t+c": [["a", "b", "c"],
function(config)
{
	let {a, b, c} = config;
	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 0;

	config.radius = t => a * Math.sin(b * t) / t + c;
	config.derivative = t => a * (Math.cos(b * t) * b - Math.sin(b * t) / t) / t;

	setFormula(oneX(a) + "sin(" + oneX(b) + "theta) / theta" + pm0(c));
	return config;
}],
"a*sin(b*t)*cos(c*t)+d": [["a", "b", "c", "d"],
function(config)
{
	let {a, b, c, d} = config;
	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 1;
	if (typeof d !== "number") d = 0;

	config.radius = t => a * Math.sin(b * t) * Math.cos(c * t) + d;
	config.derivative = t => a * (b * Math.cos(b*t) * Math.cos(c*t) - c * Math.sin(b*t) * Math.sin(c*t));

	setFormula(oneX(a) + "sin(" + oneX(b) + "theta) * cos(" + oneX(c) + "theta)" + pm0(d));
	return config;
}],
"a*t+b*cos(c*t)+d": [["a", "b", "c", "d"],
function(config)
{
	let {a, b, c, d} = config;
	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 1;
	if (typeof d !== "number") d = 0;

	config.radius = t => a * t + b * Math.cos(c * t) + d;
	config.derivative = t => a - b * c * Math.sin(c * t);

	setFormula(oneX(a) + "theta" + pm1(b) + "cos(" + oneX(c) + "theta)" + pm0(d));
	return config;
}],
"a*t+b*sin(bt*t)+c*cos(ct*t)+d": [["a", "b", "c", "d", "bt", "ct"],
function(config)
{
	let {a, b, c, d, bt, ct} = config;

	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 1;
	if (typeof d !== "number") d = 0;
	if (typeof bt !== "number") bt = 2 * Math.PI;
	if (typeof ct !== "number") ct = 2 * Math.PI;

	config.radius = t => a * t + b * Math.sin(bt * t) + c * Math.cos(ct * t) + d;
	config.derivative = t => a + b * bt * Math.cos(bt * t) - c * ct * Math.sin(ct * t);

	setFormula(oneX(a) + "theta" +
		pm1(b) + "sin(" + oneX(bt) + "theta)" +
		pm1(c) + "cos(" + oneX(ct) + "theta)" + pm0(d));
	return config;
}],
};
function setCurve(config, key, csv)
{
	if (!curveConfigs.hasOwnProperty(key)) return;

	[config.props, config.curve] = curveConfigs[key];

	if (csv) parseExprList(csv, config, config.props);
}
function parseCurve(v, config)
{
	const i = v.indexOf(",");
	if (i < 0)
		setCurve(config, v);
	else
		setCurve(config, v.substring(0, i), v.substring(i + 1));
}
function makeCurve(config)
{
	const numPoints = setAngle(config);
	const {theta, radius} = config.curve(config);
	return Array.from({length: numPoints}, (t, i) => [t = theta(i), radius(t)]);
}
function morph(config, svg)
{
	const props = [];
	const delay = config.morphDelay || 100;
	const steps = config.morphSteps || 100;
	const validProps = new Set(config.props);

	for (const prop of ["thetaStart", "thetaEnd", "thetaStep", "numPoints"])
		validProps.add(prop);

	for (const propConfig of config.morph) {
		const [prop, minValue, maxValue] = propConfig;
		if (validProps.has(prop)) {
			config[prop] = minValue;
			propConfig.push((maxValue - minValue) / steps);
			props.push(propConfig);
		}
	}

	const path = svg.appendChild(createSvgElem("path", [["class", "curve"]]));

	const update = function(oneFrame, reverse) {
		let done = !oneFrame && !reverse;
		for (const [prop, minValue, maxValue, step] of props)
			if (reverse) {
				const nextValue = config[prop] - step;
				if (step < 0 ? nextValue < minValue : nextValue > minValue)
					config[prop] = nextValue;
				else
					config[prop] = minValue;
			} else {
				const nextValue = config[prop] + step;
				if (step < 0 ? nextValue > maxValue : nextValue < maxValue) {
					done = false;
					config[prop] = nextValue;
				} else
					config[prop] = maxValue;
			}
		setRadialPath(path, makeCurve(config));
		if (done)
			animationEnd();
		else if (!oneFrame)
			animation.timeout = setTimeout(update, delay);
	};
	animationBegin(update);
}
function predefinedConfig(i)
{
	const logSpiral = curveConfigs.logspiral[1];
	const growthFactor = mathConstants.phi;
	const growthAngle = 2 * Math.PI;
	const configs = [
		{// demo=1
			curve: logSpiral,
			slopeAngle: Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		},
		{// demo=2
			curve: logSpiral,
			tangentAngle: Math.PI / 2 - Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		},
	];
	return i >= 0 && i < configs.length ? configs[i] : {};
}
function main()
{
	setTextNodes();

	let config = {};
	parseQueryString(config, {
		anim:    function(v, c) { parseAnimate(v, c, "animate"); },
		animtan: function(v, c) { parseAnimate(v, c, "animateTangent"); },
		demo:    function(v, c) { parseNumber(v, 2, c, "demo"); },
		h:       function(v, c) { parseNumber(v, 4, c, "height"); },
		points:  function(v, c) { parseNumber(v, 6, c, "numPoints"); },
		theta:   function(v, c) { parseExprList(v, c, ["thetaStart", "thetaEnd", "thetaStep"]); },
		w:       function(v, c) { parseNumber(v, 4, c, "width"); },

		center:  parseCenter,
		morph:   parseMorph,
		r:       parseCurve,
		stroke:  parseStroke,

		logspiral: function(v, c) { setCurve(c, "logspiral", v); },
		rose:      function(v, c) { setCurve(c, "rose", v); },
		sinspiral: function(v, c) { setCurve(c, "sinspiral", v); },
		spiral:    function(v, c) { setCurve(c, "spiral", v); },
	});

	if (config.demo)
		config = predefinedConfig(config.demo - 1);
	if (!config.curve)
		setCurve(config, "rose");

	const isLogSpiral = config.curve === curveConfigs.logspiral[1];
	if (!isLogSpiral) {
		removeTextRow(textNodes.growthFactor);
		removeTextRow(textNodes.growthAngle);
	}

	const svg = createSvg(config);

	if (config.morph) {
		removeTextRow(textNodes.theta);
		removeTextRow(textNodes.radius);
		if (!isLogSpiral) {
			removeTextRow(textNodes.slopeAngle);
			removeTextRow(textNodes.tangentAngle);
		}
		morph(config, svg);
		return;
	}

	const data = makeCurve(config);
	if (config.grid)
		config.grid(svg);

	const path = svg.appendChild(createSvgElem("path", [["class", "curve"]]));
	const animateTangent = config.animateTangent && config.derivative;

	if (config.animate) {
		const n = data.length;
		const {step = 8, delay = 50} = config.animate;
		let i = 1 + step * 2;
		const update = function(oneFrame, reverse) {
			let done = false;
			if (reverse) {
				if (i - step > 1) i -= step; else i = 1;
			} else
				if (i + step < n) i += step;
			else {
				i = n; if (!oneFrame) done = true;
			}
			setRadialPath(path, data.slice(0, i));
			if (!animateTangent) {
				const [t, r] = data[i - 1];
				textNodes.theta.nodeValue = toStr2(t * 180 / Math.PI);
				textNodes.radius.nodeValue = toStr2(r);
				if (done)
					animationEnd();
				else if (!oneFrame)
					animation.timeout = setTimeout(update, delay);
			} else if (!done)
				setTimeout(update, delay);
		};
		if (animateTangent)
			update(false, true);
		else
			animationBegin(update);
	} else {
		setRadialPath(path, data);
		if (!animateTangent) {
			const [t, r] = data[data.length - 1];
			textNodes.theta.nodeValue = toStr2(t * 180 / Math.PI);
			textNodes.radius.nodeValue = toStr2(r);
		}
	}

	if (animateTangent) {
		const radial = svg.appendChild(createSvgElem("line", [["class", "radial"]]));
		const tangent = svg.appendChild(createSvgElem("line", [["class", "tangent"]]));
		const tangentArc = svg.appendChild(createSvgElem("path", [["class", "tangentArc"]]));

		let i = 0;
		const n = data.length - 1;
		const {step = 4, delay = 100} = config.animateTangent;
		const update = function(oneFrame, reverse) {
			let done = false;
			if (reverse) {
				if (i - step > 0) i -= step; else i = 0;
			} else
				if (i + step < n) i += step;
			else {
				i = n; if (!oneFrame) done = true;
			}
			updateTangent(i, config, radial, tangent, tangentArc);
			if (done)
				animationEnd();
			else if (!oneFrame)
				animation.timeout = setTimeout(update, delay);
		};
		animationBegin(update);
	}
	else if (!isLogSpiral) {
		removeTextRow(textNodes.slopeAngle);
		removeTextRow(textNodes.tangentAngle);
	}
}
window.addEventListener("DOMContentLoaded", main);
})();
</script>
</head>
<body>
<table id="layout">
<tr>
<td>&nbsp;</td>
<td id="formulaParent">radius = <span id="formula">&nbsp;</span></td>
</tr>
<tr>
<td><table id="params">
<tr><td>       theta =</td><td><span id="theta">&nbsp;</span>&deg;</td></tr>
<tr><td>      radius =</td><td><span id="radius">&nbsp;</span></td></tr>
<tr><td>  thetaStart =</td><td><span id="thetaStart">&nbsp;</span>&deg;</td></tr>
<tr><td>    thetaEnd =</td><td><span id="thetaEnd">&nbsp;</span></td></tr>
<tr><td>   thetaStep =</td><td><span id="thetaStep">&nbsp;</span>&deg;</td></tr>
<tr><td>   numPoints =</td><td><span id="numPoints">&nbsp;</span></td></tr>
<tr><td>  slopeAngle =</td><td><span id="slopeAngle">&nbsp;</span>&deg;</td></tr>
<tr><td>tangentAngle =</td><td><span id="tangentAngle">&nbsp;</span>&deg;</td></tr>
<tr><td>growthFactor =</td><td><span id="growthFactor">&nbsp;</span></td></tr>
<tr><td> growthAngle =</td><td><span id="growthAngle">&nbsp;</span>&deg;</td></tr>
</table></td>
<td id="graph"></td>
</tr>
<tr>
<td>&nbsp;</td>
<td><table id="examples" class="borderTable">
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Logarithmic_spiral">Logarithmic Spirals</a></th></tr>
<tr>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4">r = 40*phi^(theta/(2pi))</a></td>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4&anim">Animate</a>
/   <a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4&animtan">Tangent</a></td>
<td>0 - 8pi</td>
<td>growthFactor = phi
<br>growthAngle = 2pi</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4">r = 40*e^(theta*tan(6pi/180))</a></td>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4&anim">Animate</a>
/   <a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4&animtan">Tangent</a></td>
<td>0 - 8pi</td>
<td>slopeAngle = 6&deg;</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4">r = 40*e^(theta/tan(84pi/180))</a></td>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4&anim">Animate</a>
/   <a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4&animtan">Tangent</a></td>
<td>0 - 8pi</td>
<td>tangentAngle = 84&deg;</td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Rose_(mathematics)">Roses</a></th></tr>
<tr>
<td><a href="polar.html?rose=,4/9&theta=,18pi,pi/180">r = 200*cos(4/9*theta)</a></td>
<td><a href="polar.html?rose=,4/9&theta=,18pi,pi/180&anim=32">Animate</a>
/   <a href="polar.html?rose=,4/9&theta=,18pi,pi/180&animtan">Tangent</a></td>
<td>0 - 18pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,5,60&theta=,2pi,pi/180">r = 200*cos(5*theta) + 60</a></td>
<td><a href="polar.html?rose=,5,60&theta=,2pi,pi/180&anim">Animate</a>
/   <a href="polar.html?rose=,5,60&theta=,2pi,pi/180&animtan=1">Tangent</a></td>
<td>0 - 2pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,pi&theta=,32pi,pi/180">r = 200*cos(pi*theta)</a></td>
<td><a href="polar.html?rose=,pi&theta=,32pi,pi/180&anim=16,20">Animate</a>
/   <a href="polar.html?rose=,pi&theta=,32pi,pi/180&animtan">Tangent</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,e&theta=,32pi,pi/180">r = 200*cos(e*theta)</a></td>
<td><a href="polar.html?rose=,e&theta=,32pi,pi/180&anim=16,20">Animate</a>
/   <a href="polar.html?rose=,e&theta=,32pi,pi/180&animtan">Tangent</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=200,1,100&theta=,2pi">r = 200*cos(theta) + 100</a></td>
<td><a href="polar.html?rose=200,1,100&theta=,2pi&anim">Animate</a>
/   <a href="polar.html?rose=200,1,100&theta=,2pi&animtan">Tangent</a></td>
<td>0 - 2pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lima%C3%A7on">Lima&ccedil;on</a></td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Archimedean_spiral">Archimedean Spirals</a></th></tr>
<tr>
<td><a href="polar.html?spiral=,12&theta=,8pi">r = 12*theta</a></td>
<td><a href="polar.html?spiral=,12&theta=,8pi&anim">Animate</a>
/   <a href="polar.html?spiral=,12&theta=,8pi&animtan">Tangent</a></td>
<td>0 - 8pi</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><a href="polar.html?spiral=,40,2&theta=,16pi">r = 40*sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,40,2&theta=,16pi&anim">Animate</a>
/   <a href="polar.html?spiral=,40,2&theta=,16pi&animtan=,50">Tangent</a></td>
<td>0 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Fermat%27s_spiral">Fermat's spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi">r = 400/theta</a></td>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&anim">Animate</a>
/   <a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&animtan">Tangent</a></td>
<td>pi/4 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Hyperbolic_spiral">Hyperbolic spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi">r = 240/sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&anim">Animate</a>
/   <a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&animtan">Tangent</a></td>
<td>pi/12 - 32pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lituus_(mathematics)">Lituus</a></td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Sinusoidal_spiral">Sinusoidal Spirals</a></th></tr>
<tr>
<td><a href="polar.html?sinspiral=10,-1/3&theta=-5pi/4,5pi/4,pi/360">r = 10/cos(&minus;theta/3)^3</a></td>
<td><a href="polar.html?sinspiral=10,-1/3&theta=-5pi/4,5pi/4,pi/360&anim">Animate</a>
/   <a href="polar.html?sinspiral=10,-1/3&theta=-5pi/4,5pi/4,pi/360&animtan">Tangent</a></td>
<td>&minus;5pi/4 - 5pi/4</td>
<td><a href="https://en.wikipedia.org/wiki/Tschirnhausen_cubic">Tschirnhausen cubic</a>
<br>thetaStep = 0.5&deg;</td>
</tr>
<tr>
<td><a href="polar.html?sinspiral=400,1/3&theta=0,3pi,pi/180">r = 400*cos(theta/3)^3</a></td>
<td><a href="polar.html?sinspiral=400,1/3&theta=0,3pi,pi/180&anim">Animate</a>
/   <a href="polar.html?sinspiral=400,1/3&theta=0,3pi,pi/180&animtan">Tangent</a></td>
<td>0 - 3pi</td>
<td><a href="https://en.wikipedia.org/wiki/Cayley%27s_sextic">Cayley's sextic</a>
<br>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?sinspiral=400,2&theta=0,2pi,pi/18000">r = 400*sqrt(cos(2*theta))</a></td>
<td><a href="polar.html?sinspiral=400,2&theta=0,2pi,pi/18000&anim=200">Animate</a>
/   <a href="polar.html?sinspiral=400,2&theta=0,2pi,pi/18000&animtan=100">Tangent</a></td>
<td>0 - 2pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lemniscate_of_Bernoulli">Lemniscate of Bernoulli</a>
<br>thetaStep = 0.01&deg;</td>
</tr>
<tr><th colspan="4">Other Curves</th></tr>
<tr>
<td><a href="polar.html?r=a*sin(b*t)*t+c,9,1,0&theta=0,12pi">r = 9*sin(theta)*theta</a></td>
<td><a href="polar.html?r=a*sin(b*t)*t+c,9,1,0&theta=0,12pi&anim">Animate</a>
/   <a href="polar.html?r=a*sin(b*t)*t+c,9,1,0&theta=0,12pi&animtan">Tangent</a></td>
<td>0 - 12pi</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><a href="polar.html?r=a*sin(b*t)/t+c,400&theta=-12pi,12pi,pi/720">r = 400*sin(theta)/theta</a></td>
<td><a href="polar.html?r=a*sin(b*t)/t+c,400&theta=-12pi,12pi,pi/720&anim=100">Animate</a>
/   <a href="polar.html?r=a*sin(b*t)/t+c,400&theta=-12pi,12pi,pi/720&animtan=100">Tangent</a></td>
<td>&minus;12pi - 12pi</td>
<td><a href="https://en.wikipedia.org/wiki/Cochleoid">Cochleoid</a>
<br>thetaStep = 0.25&deg;</td>
</tr>
<tr>
<td><a href="polar.html?r=a*t+b*cos(c*t)+d,4,56,3e,56&theta=,16pi">r = 4*theta + 56*cos(3*e*theta) + 56</a></td>
<td><a href="polar.html?r=a*t+b*cos(c*t)+d,4,56,3e,56&theta=,16pi&anim">Animate</a>
/   <a href="polar.html?r=a*t+b*cos(c*t)+d,4,56,3e,56&theta=,16pi&animtan=2">Tangent</a></td>
<td>0 - 16pi</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><a href="polar.html?r=a*sin(b*t)*cos(c*t)+d,200,5,1,200&theta=,2pi">r = 200*sin(5*theta)*cos(theta) + 200</a></td>
<td><a href="polar.html?r=a*sin(b*t)*cos(c*t)+d,200,5,1,200&theta=,2pi&anim">Animate</a>
/   <a href="polar.html?r=a*sin(b*t)*cos(c*t)+d,200,5,1,200&theta=,2pi&animtan=2">Tangent</a></td>
<td>0 - 2pi</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,36,7,60,5pi,5pi&theta=0,25pi/2">r = 9*theta
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ 36*sin(5pi*theta)
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ 7*cos(5pi*theta) + 60</a></td>
<td><a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,36,7,60,5pi,5pi&theta=0,25pi/2&anim">Animate</a>
/   <a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,36,7,60,5pi,5pi&theta=0,25pi/2&animtan">Tangent</a></td>
<td>0 - 25pi/2</td>
<td>&nbsp;</td>
</tr>
<tr><th colspan="4">Morphs</th></tr>
<tr>
<td colspan="2"><a href="polar.html?rose&morph=200,100,scale:100:300,k:e:e+2,offset:-100:100&theta=,32pi,pi/180">r = scale * cos(k*theta) + offset</a>
<div class="morph">
<div>     k =</div><div>         e &rarr;</div><div>e+2</div>
<div> scale =</div><div>       100 &rarr;</div><div>300</div>
<div>offset =</div><div>&minus;100 &rarr;</div><div>100</div>
</div></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 200
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?rose=100,4/9&morph=440,20,offset:-220:220&theta=,18pi,pi/180">r = 100 * cos(4/9 * theta) + offset</a>
<div class="morph">
<div>offset =</div><div>&minus;220 &rarr;</div><div>220</div>
</div></td>
<td>0 - 18pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 440
<br>morphDelay = 20ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?rose=100,5&morph=500,20,offset:-250:250&theta=,2pi,pi/180">r = 100 * cos(5 * theta) + offset</a>
<div class="morph">
<div>offset =</div><div>&minus;250 &rarr;</div><div>250</div>
</div></td>
<td>0 - 2pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 500
<br>morphDelay = 20ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?rose=,,0&morph=200,200,scale:200:340,k:pi-1:pi+1&theta=,32pi,pi/180">r = scale * cos(k * theta)</a>
<div class="morph">
<div>    k =</div><div>pi&minus;1 &rarr;</div><div>pi+1</div>
<div>scale =</div><div>         200 &rarr;</div><div>   340</div>
</div></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 200
<br>morphDelay = 200ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?spiral=,10&morph=130,200,numPoints:20:280&theta=,16pi">r = 10 * theta</a></td>
<td>0 - 16pi</td>
<td><div class="morph">
<div>numPoints =</div><div>20 &rarr;</div><div>280</div>
</div>
morphSteps = 130
<br>morphDelay = 200ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?spiral=,6&morph=179,100,thetaStep:pi/360:pi/2&points=80">r = 6 * theta</a></td>
<td>&nbsp;</td>
<td><div class="morph">
<div>thetaStep =</div><div>pi/360 &rarr;</div><div>pi/2</div>
</div>
numPoints = 80
<br>morphSteps = 179
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?spiral=,6&morph=180,100,thetaStep:pi/2:pi&points=120">r = 6 * theta</a></td>
<td>&nbsp;</td>
<td><div class="morph">
<div>thetaStep =</div><div>pi/2 &rarr;</div><div>pi</div>
</div>
numPoints = 120
<br>morphSteps = 180
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*sin(b*t)*t+c,9&theta=0,12pi,pi/360&morph=400,100,b:1:17,c:0:17">r = 9*sin(b*theta)*theta + c</a>
<div class="morph">
<div>b =</div><div>1 &rarr;</div><div>17</div>
<div>c =</div><div>0 &rarr;</div><div>17</div>
</div></td>
<td>0 - 12pi</td>
<td>thetaStep = 0.5&deg;
<br>morphSteps = 400
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*sin(b*t)*cos(c*t)+d,-200,1,1,200&theta=0,2pi,pi/720&morph=80,100,b:-40:40">r = &minus;200*sin(b*theta)*cos(theta) + 200</a>
<div class="morph">
<div>b =</div><div>&minus;40 &rarr;</div><div>40</div>
</div></td>
<td>0 - 2pi</td>
<td>thetaStep = 0.25&deg;
<br>morphSteps = 80
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*sin(b*t)*cos(c*t)+d,-320,0.14,1.14,200&theta=0,50pi&h=800&center=,160&morph=100,100,b:0.14:5.14,c:1.14:6.14">r = &minus;320*sin(b*theta)*cos(c*theta) + 200</a>
<div class="morph">
<div>b =</div><div>0.14 &rarr;</div><div>5.14</div>
<div>c =</div><div>1.14 &rarr;</div><div>6.14</div>
</div></td>
<td>0 - 50pi</td>
<td>morphSteps = 100
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*sin(b*t)*cos(c*t)+d,-320,0.14,1.14,200&theta=0,50pi&h=1100&morph=200,100,a:-400:400">r = a*sin(0.14*theta)*cos(1.14*theta) + 200</a>
<div class="morph">
<div>a =</div><div>&minus;400 &rarr;</div><div>400</div>
</div></td>
<td>0 - 50pi</td>
<td>morphSteps = 200
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,36,1,0,2pi,2pi&theta=0,24pi&morph=120,50,c:-360:360">r = 9*theta
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ 36*sin(2pi*theta)
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ c*cos(2pi*theta)</a>
<div class="morph">
<div>c =</div><div>&minus;360 &rarr;</div><div>360</div>
</div></td>
<td>0 - 24pi</td>
<td>morphSteps = 120
<br>morphDelay = 50ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,27,-99,0,8,8&theta=0,32pi&morph=210,40,d:-720:120">r = 9*theta
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ 27*sin(8*theta)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&minus; 99*cos(8*theta) + d</a>
<div class="morph">
<div>d =</div><div>&minus;720 &rarr;</div><div>120</div>
</div></td>
<td>0 - 32pi</td>
<td>morphSteps = 210
<br>morphDelay = 40ms</td>
</tr>
</table><br>
<table id="urlparams" class="borderTable">
<tr><th colspan="3">URL Parameters</th></tr>
<tr>
<td>anim=</td>
<td>[step],[delay]</td>
<td>Run the curve drawing animation.
<br>Draw [step] points per frame of the animation.
<br>Pause [delay] milliseconds between each frame of the animation.</td>
</tr>
<tr>
<td>animtan=</td>
<td>[step],[delay]</td>
<td>Run the tangent line animation.
<br>Move [step] points per frame of the animation.
<br>Pause [delay] milliseconds between each frame of the animation.</td>
</tr>
<tr>
<td>center=</td>
<td>[offsetX],[offsetY]</td>
<td>Specify the offset of the origin from the center of the graph.</td>
</tr>
<tr>
<td>h=</td>
<td>[height]</td>
<td>Set the height of the graph in pixels.</td>
</tr>
<tr>
<td>logspiral=</td>
<td>[initialRadius]
<br>,[slopeAngle],[tangentAngle]
<br>,[growthFactor],[growthAngle]</td>
<td>Angles are expected in radians.
<br>If [slopeAngle] is specified:
<br>r = [initialRadius] * e ^ (theta * tan([slopeAngle]))
<br>Otherwise, if [tangentAngle] is specified:
<br>r = [initialRadius] * e ^ (theta / tan([tangentAngle]))
<br>Otherwise:
<br>r = [initialRadius] * [growthFactor] ^ (theta / [growthAngle])
</td>
</tr>
<tr>
<td>morph=</td>
<td>[numSteps],[delay]
<br>,[curveParam1]:[beginValue1]:[endValue1]
<br>,[curveParam2]:[beginValue2]:[endValue2]
<br>...</td>
<td>Redraw the curve every [delay] milliseconds.
<br>On each iteration, each [curveParam] will be changed by
<br>([endValue] - [beginValue]) / [numSteps]</td>
</tr>
<tr>
<td>points=</td>
<td>[numPoints]</td>
<td>Set the number of points for the curve.</td>
</tr>
<tr>
<td>r=</td>
<td>[curve],[param1Value],[param2Value] ...</td>
<td><table class="borderTable">
<tr><td> Curve                         </td><td> Parameters         </td></tr>
<tr><td> a*sin(b*t)*t+c                </td><td> a, b, c            </td></tr>
<tr><td> a*sin(b*t)/t+c                </td><td> a, b, c            </td></tr>
<tr><td> a*sin(b*t)*cos(c*t)+d         </td><td> a, b, c, d         </td></tr>
<tr><td> a*t+b*cos(c*t)+d              </td><td> a, b, c, d         </td></tr>
<tr><td> a*t+b*sin(bt*t)+c*cos(ct*t)+d </td><td> a, b, c, d, bt, ct </td></tr>
</table>
</td>
</tr>
<tr>
<td>rose=</td>
<td>[scale],[k],[offset]</td>
<td>r = [scale] * cos([k] * theta) + [offset]</td>
</tr>
<tr>
<td>sinspiral=</td>
<td>[a],[n],[b]</td>
<td>r = [a] * cos([n] * theta) ^ (1 / [n]) + [b]</td>
</tr>
<tr>
<td>spiral=</td>
<td>[a],[b],[c]</td>
<td>r = [a] + [b] * theta ^ (1 / [c])</td>
</tr>
<tr>
<td>stroke=</td>
<td>[color],[width]</td>
<td>Set the stroke color and/or width.</td>
</tr>
<tr>
<td>theta=</td>
<td>[start],[end],[step]</td>
<td>Set the start angle, end angle, and/or angular step in radians.
<br>[start] is the angle for the first point of the curve.
<br>[end] is the angle for the last point of the curve.
</td>
</tr>
<tr>
<td>w=</td>
<td>[width]</td>
<td>Set the width of the graph in pixels.</td>
</tr>
</table>
<br><a href="https://github.com/nightjuggler/math/blob/master/polar.html">Code &amp; design</a>
by <a href="https://github.com/nightjuggler">Pius Fischer</a>
<br>Additional design input by Dancin' Angie
<br>Default color gradient adapted from
<a href="https://www.visualcinnamon.com/2016/05/smooth-color-legend-d3-svg-gradient.html">Nadieh Bremer</a> via
<a href="https://bl.ocks.org/mbostock/db6b4335bf1662b413e7968910104f0f">Mike Bostock</a></td>
</tr>
</table>
<svg width="0" height="0">
<defs>
<radialGradient id="gradient1">
	<stop   offset="0.0%" stop-color="#2c7bb6" />
	<stop  offset="12.5%" stop-color="#00a6ca" />
	<stop  offset="25.0%" stop-color="#00ccbc" />
	<stop  offset="37.5%" stop-color="#90eb9d" />
	<stop  offset="50.0%" stop-color="#ffff8c" />
	<stop  offset="62.5%" stop-color="#f9d057" />
	<stop  offset="75.0%" stop-color="#f29e2e" />
	<stop  offset="87.5%" stop-color="#e76818" />
	<stop offset="100.0%" stop-color="#d7191c" />
</radialGradient>
<radialGradient id="gradient2" r="25%" spreadMethod="reflect">
	<stop   offset="0%" stop-color="gold" />
	<stop offset="100%" stop-color="red" />
</radialGradient>
</defs>
</svg>
</body>
</html>
