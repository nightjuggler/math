<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Polar Curve Explorer</title>
<style>
a {
	text-decoration: none;
}
body {
	background-color: white;
	font-family: verdana;
	font-size: 10pt;
}
table {
	border: 1px solid black;
	border-spacing: 0;
	margin-left: auto;
	margin-right: auto;
	margin-top: 2px;
}
td,th {
	border: 1px solid black;
	padding: 2px 4px 2px 4px;
	vertical-align: top;
}
th {
	background-color: rgb(220,220,220);
}
#graph {
	text-align: center;
}
#graph div {
	padding-bottom: 2px;
}
#graph svg {
	border: 1px solid black;
	margin-top: 2px;
}
.axis {
	fill: none;
	stroke: black;
	stroke-opacity: 0.3;
	stroke-width: 1px;
}
.curve {
	fill: none;
	stroke: url(#gradient1);
	stroke-width: 2px;
}
.radial {
	stroke: green;
	stroke-width: 2px;
}
.tangent {
	stroke: blue;
	stroke-width: 2px;
}
.tangentAngle {
	fill: none;
	stroke: red;
	stroke-width: 4px;
}
</style>
<script>
/* globals document, window, clearTimeout, setTimeout */
(function() {
"use strict";
const mathConstants = {
	e: Math.E,
	phi: (1 + Math.sqrt(5)) / 2,
	pi: Math.PI,
};
var animation;
function handleKeyDown(event)
{
	if (!animation) return true;

	switch (event.key || event.keyIdentifier) {
		case "ArrowLeft":
		case "Left":
			if (animation.timeout !== null) return true;
			animation.update(true, true);
			break;
		case "ArrowRight":
		case "Right":
			if (animation.timeout !== null) return true;
			animation.update(true);
			break;
		case "U+0020":
		case " ":
			if (animation.timeout !== null) {
				clearTimeout(animation.timeout);
				animation.timeout = null;
			} else
				animation.update();
			break;
		default:
			return true;
	}

	event.preventDefault();
	event.stopPropagation();
	return false;
}
function animationBegin(update)
{
	document.addEventListener("keydown", handleKeyDown);
	animation = {update: update};
	update(false, true);
}
function animationEnd()
{
	document.removeEventListener("keydown", handleKeyDown);
	animation = null;
}
function createSvgElem(tagName, attributes)
{
	const svgNS = "http://www.w3.org/2000/svg";
	const element = document.createElementNS(svgNS, tagName);

	for (const [name, value] of attributes)
		element.setAttribute(name, value);

	return element;
}
function createSvg(width, height)
{
	const centerX = Math.floor(width / 2);
	const centerY = Math.floor(height / 2);

	const svg = document.getElementById("graph")
		.appendChild(createSvgElem("svg", [["width", width], ["height", height]]))
		.appendChild(createSvgElem("g", [["transform", "translate(" + centerX + "," + centerY + ")"]]));

	svg.appendChild(createSvgElem("line", [["class", "axis"],
		["x1", 0], ["y1", centerY],
		["x2", 0], ["y2", -centerY]]));
	svg.appendChild(createSvgElem("line", [["class", "axis"],
		["x1", -centerX], ["y1", 0],
		["x2", centerX], ["y2", 0]]));

	return svg;
}
function parseAnimate(q, v, propName)
{
	const m = v.match(/^([1-9][0-9]{0,2})?,([1-9][0-9]{1,3})?$/);
	if (m === null) return;
	const [, step, delay] = m;
	const animate = {};
	if (step) animate.step = parseInt(step, 10);
	if (delay) animate.delay = parseInt(delay, 10);
	q[propName] = animate;
}
function parseDemo(q, v)
{
	if (v.match(/^[1-9][0-9]?$/) !== null)
		q.demo = parseInt(v, 10);
}
function parseExpr(q, v, propName)
{
	if (v === "") return;
	const m = v.match(/^(-?(?:[1-9][0-9]*|0)(?:\.[0-9]+)?)?(e|phi|pi)?(?:\/([1-9][0-9]*))?$/);
	if (m === null) return;
	const [, a, b, c] = m;
	if (!(a || b)) return;
	v = a ? Number(a) : 1;
	if (b) v *= mathConstants[b];
	if (c) v /= Number(c);
	q[propName] = v;
}
function parseExprList(q, v, propList)
{
	const values = v.split(",");
	const numValues = values.length > propList.length ? propList.length : values.length;

	for (let i = 0; i < numValues; i += 1)
		parseExpr(q, values[i], propList[i]);
}
function parsePoints(q, v)
{
	if (v.match(/^[1-9][0-9]{0,5}$/) !== null)
		q.numPoints = parseInt(v, 10);
}
function parseStroke(q, v)
{
	const m = v.match(/^(?:([A-Za-z]+)|(gradient[1-9]))?(?:,([1-9][0-9]?))?$/);
	if (m === null) return;

	let [, color, gradient, width] = m;
	if (gradient)
		color = "url(#" + gradient + ")";
	if (width)
		width += "px";

	for (const rule of document.styleSheets[0].cssRules)
		if (rule.selectorText === ".curve") {
			if (color)
				rule.style.setProperty("stroke", color);
			if (width)
				rule.style.setProperty("stroke-width", width);
			break;
		}
}
function isValidId(s, n)
{
	return s.length <= n && s.match(/^[a-z][_0-9a-z]*$/) !== null;
}
function parseQueryString(params, handlers, flags)
{
	const q = window.location.search;

	if (typeof q !== 'string' || q.charAt(0) !== '?') return;

	if (!flags) flags = {};
	if (!handlers) handlers = {};

	for (const s of q.substr(1).split('&'))
	{
		const i = s.indexOf('=');
		if (i < 0 && isValidId(s, 6) && flags[s]) {
			params[flags[s]] = true;
			continue;
		}
		if (i < 1 || i === s.length - 1) continue;
		const k = s.substr(0, i);
		const v = s.substr(i + 1);

		if (isValidId(k, 12) && handlers[k])
			handlers[k](params, v);
	}
}
function setRadialPath(path, data)
{
	path.setAttribute("d", Array.from(data, ([t, r], i) => (i === 0 ? "M" : "L") +
		( r * Math.cos(t)).toFixed(4) + "," +
		(-r * Math.sin(t)).toFixed(4)).join(""));
}
function updateTangent(i, config, tangent, radial, tangentAngle, textNode)
{
/*
	The slope m of the line tangent to the curve r = f(t) at point (r, t) is

	m = dy/dx = ( (dr/dt)*sin(t) + r*cos(t) ) / ( (dr/dt)*cos(t) - r*sin(t) )
*/
	const {derivative, radius, theta} = config;

	const drdt = derivative(i);
	const r = radius(i);
	const sin = Math.sin(theta(i));
	const cos = Math.cos(theta(i));
	const x = r * cos;
	const y = r * sin;
	const m = (drdt * sin + x) / (drdt * cos - y);
/*
	The tangent of the slope angle a of the tangent line is the slope m: tan(a) = m

	To move a distance h along the tangent line, calculate dx and dy:

	dx = h * cos(a) = h / sqrt(1 + tan(a)*tan(a)) = h / sqrt(1 + m*m)
	dy = h * sin(a) = h * tan(a) / sqrt(1 + tan(a)*tan(a)) = tan(a) * dx = m * dx
*/
	const h = 200;
	const dx = h / Math.sqrt(1 + m * m);
	const dy = dx === 0 ? h : m * dx;

	tangent.setAttribute("x1", x + dx);
	tangent.setAttribute("y1", -(y + dy));
	tangent.setAttribute("x2", x - dx);
	tangent.setAttribute("y2", -(y - dy));
	radial.setAttribute("x2", x);
	radial.setAttribute("y2", -y);

	const arcRadius = 20;
	if (r > arcRadius) {
		const arcX1 = (r - arcRadius) * cos;
		const arcY1 = (r - arcRadius) * sin;
		let arcDx = arcRadius / Math.sqrt(1 + m * m);
		let arcDy = arcDx === 0 ? arcRadius : m * arcDx;

		if (m > 0 ? drdt < 0 ? sin <= 0 : cos > 0 : drdt < 0 ? cos <= 0 : sin <= 0) {
			arcDy = -arcDy;
			arcDx = -arcDx;
		}

		tangentAngle.setAttribute("d", [
			"M", arcX1, -arcY1,
			"A", arcRadius, arcRadius, 0, 0, 0, x + arcDx, -(y + arcDy),
		].join(" "));
	} else
		tangentAngle.setAttribute("d", "");
/*
	The tangent of the tangent angle psi of the curve r = f(t) at point (r, t) is

	tan(psi) = r / (dr/dt)

	The tangent angle is the angle between the radial line from the origin to the point (r, t)
	and the line tangent to the curve at point (r, t).

	The slope angle of the curve at point (r, t) is pi/2 - psi
*/
	if (textNode) {
		const tangentAngle = Math.atan2(r, drdt) * 180 / Math.PI;
		const slopeAngle = 90 - tangentAngle;
		textNode.nodeValue = "slope angle = " + slopeAngle.toFixed(2) + " degrees, " +
			"tangent angle = " + tangentAngle.toFixed(2) + " degrees";
	}
}
function setAngle(config)
{
	let {thetaStart, thetaEnd, thetaStep, numPoints} = config;

	if (typeof thetaStart !== "number")
		thetaStart = 0;

	if (typeof thetaEnd === "number" && thetaStart < thetaEnd) {
		if (typeof thetaStep === "number" && thetaStep > 0)
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		else if (typeof numPoints === "number" && numPoints > 1)
			thetaStep = (thetaEnd - thetaStart) / (numPoints - 1);
		else {
			thetaStep = Math.PI / 180; // 1 degree;
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		}
	} else {
		if (!(typeof thetaStep === "number" && thetaStep > 0))
			thetaStep = Math.PI / 180; // 1 degree;
		if (!(typeof numPoints === "number" && numPoints > 1))
			numPoints = 12*360 + 1;
	}

	config.theta = i => thetaStart + i * thetaStep;
	config.thetaStart = thetaStart;
	config.thetaStep = thetaStep;
	config.numPoints = numPoints;

	return config.theta;
}
function logSpiral(config)
{
	const theta = setAngle(config);

	let {initialRadius, slopeAngle, tangentAngle, growthFactor, growthAngle} = config;

	if (!(typeof initialRadius === "number" && initialRadius !== 0))
		initialRadius = 40;
	if (!(typeof growthFactor === "number" && growthFactor > 0))
		growthFactor = 1.5;
	if (!(typeof growthAngle === "number" && growthAngle > 0))
		growthAngle = Math.PI; // 180 degrees

	if (typeof slopeAngle === "number") {
		// tangentAngle = math.PI / 2 - slopeAngle;

		const k = Math.tan(slopeAngle);
		const radius = i => initialRadius * Math.exp(k * theta(i));
		config.radius = radius;
		config.derivative = i => k * radius(i);
		growthFactor = Math.exp(k * growthAngle);

	} else if (typeof tangentAngle === "number" && tangentAngle !== 0) {

		const k = 1 / Math.tan(tangentAngle);
		const radius = i => initialRadius * Math.exp(k * theta(i));
		config.radius = radius;
		config.derivative = i => k * radius(i);
		growthFactor = Math.exp(k * growthAngle);

	} else {
		const k = Math.log(growthFactor) / growthAngle;
		const radius = i => initialRadius * Math.pow(growthFactor, theta(i) / growthAngle);
		config.radius = radius;
		config.derivative = i => k * radius(i);
	}

	config.grid = function(svg) {
		for (let i = 0; i < 6; i += 1)
			svg.appendChild(createSvgElem("circle", [["class", "axis"], ["cx", 0], ["cy", 0],
				["r", initialRadius * Math.pow(growthFactor, i)]]));
	};
	return config;
}
function roseCurve(config)
{
	const theta = setAngle(config);

	let {scale, k, offset} = config;

	if (!(typeof scale === "number" && scale > 0))
		scale = 200;
	if (typeof k !== "number")
		k = 4 / 9;
	if (typeof offset !== "number")
		offset = 0;

	config.radius = i => scale * Math.cos(k * theta(i)) + offset;
	config.derivative = i => scale * k * -Math.sin(k * theta(i));

	config.grid = function(svg) {
		svg.appendChild(createSvgElem("circle", [["class", "axis"], ["cx", 0], ["cy", 0], ["r", scale]]));
	};
	return config;
}
function spiral(config)
{
	const theta = setAngle(config);

	let {a, b, c} = config;

	if (typeof a !== "number") a = 0;
	if (typeof b !== "number") b = 12;
	if (typeof c !== "number" || c === 0) c = 1;

	if (c === 1) {
		config.radius = i => a + b * theta(i);
		config.derivative = i => b;
	} else {
		config.radius = i => a + b * Math.pow(theta(i), 1 / c);
		config.derivative = i => b * Math.pow(theta(i), 1 / c - 1) / c;
	}
	return config;
}
function morph(config, svg)
{
	const props = config.morph;
	const delay = config.morphDelay || 100;

	for (const [prop, minValue] of props)
		config[prop] = minValue;

	const path = svg.appendChild(createSvgElem("path", [["class", "curve"]]));

	const update = function(oneFrame, reverse) {
		let done = !oneFrame && !reverse;
		for (const [prop, minValue, maxValue, step] of props)
			if (reverse) {
				if (config[prop] - step > minValue)
					config[prop] -= step;
				else
					config[prop] = minValue;
			} else if (config[prop] + step < maxValue) {
				done = false;
				config[prop] += step;
			} else
				config[prop] = maxValue;

		const {numPoints, theta, radius} = config.curve(config);
		const data = Array.from({length: numPoints}, (v, i) => [theta(i), radius(i)]);
		setRadialPath(path, data);
		if (done)
			animationEnd();
		else if (!oneFrame)
			animation.timeout = setTimeout(update, delay);
	};
	animationBegin(update);
}
function predefinedConfig(i)
{
	const growthFactor = mathConstants.phi;
	const growthAngle = 2 * Math.PI;
	const configs = [
		{// demo=1
			curve: logSpiral,
			slopeAngle: Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		},
		{// demo=2
			curve: logSpiral,
			tangentAngle: Math.PI / 2 - Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		},
		{// demo=3
			curve: roseCurve,
			morph: [
				["scale", 100, 300, 1],
				["k", Math.E, Math.E + 2, 0.01],
				["offset", -100, 100, 1],
			],
			morphDelay: 100,
			thetaEnd: 32 * Math.PI,
			thetaStep: Math.PI / 180,
		},
		{// demo=4
			curve: roseCurve,
			scale: 100, k: 4/9,
			morph: [["offset", -220, 220, 1]],
			morphDelay: 20,
			thetaEnd: 18 * Math.PI,
			thetaStep: Math.PI / 180,
		},
		{// demo=5
			curve: roseCurve,
			scale: 100, k: 5,
			morph: [["offset", -250, 250, 1]],
			morphDelay: 20,
			thetaEnd: 2 * Math.PI,
			thetaStep: Math.PI / 180,
		},
		{// demo=6
			curve: roseCurve,
			offset: 0,
			morph: [
				["scale", 200, 340, 140/200],
				["k", Math.PI - 1, Math.PI + 1, 2/200],
			],
			morphDelay: 200,
			thetaEnd: 32 * Math.PI,
			thetaStep: Math.PI / 180,
		},
		{// demo=7
			curve: spiral,
			b: 10,
			morph: [["numPoints", 20, 280, 2], ["thetaStep", 0, 0, 64]],
			morphDelay: 200,
			thetaEnd: 16 * Math.PI,
		},
		{// demo=8
			curve: spiral,
			b: 6,
			morph: [["thetaStep", Math.PI/360, Math.PI/2, Math.PI/360]],
			morphDelay: 100,
			numPoints: 80,
		},
	];
	return i >= 0 && i < configs.length ? configs[i] : {};
}
function main()
{
	let config = {};
	parseQueryString(config, {
		anim: function(q, v) {
			parseAnimate(q, v, "animate");
		},
		animtan: function(q, v) {
			parseAnimate(q, v, "animateTangent");
		},
		demo: parseDemo,
		logspiral: function(q, v) {
			q.curve = logSpiral;
			parseExprList(q, v, ["initialRadius", "slopeAngle", "tangentAngle",
				"growthFactor", "growthAngle"]);
		},
		points: parsePoints,
		rose: function(q, v) {
			q.curve = roseCurve;
			parseExprList(q, v, ["scale", "k", "offset"]);
		},
		spiral: function(q, v) {
			q.curve = spiral;
			parseExprList(q, v, ["a", "b", "c"]);
		},
		stroke: parseStroke,
		theta: function(q, v) {
			parseExprList(q, v, ["thetaStart", "thetaEnd", "thetaStep"]);
		},
	}, {});

	if (config.demo)
		config = predefinedConfig(config.demo - 1);
	if (!config.curve)
		config.curve = roseCurve;

	const svg = createSvg(900, 680);

	if (config.morph) {
		morph(config, svg);
		return;
	}

	const {numPoints, theta, radius} = config.curve(config);
	const data = Array.from({length: numPoints}, (v, i) => [theta(i), radius(i)]);

	if (config.grid)
		config.grid(svg);

	const path = svg.appendChild(createSvgElem("path", [["class", "curve"]]));

	if (config.animate) {
		let i = 0;
		const {step = 8, delay = 50} = config.animate;
		const update = function() {
			i += step;
			setRadialPath(path, data.slice(0, i));
			if (i < numPoints)
				setTimeout(update, delay);
		};
		update();
	} else
		setRadialPath(path, data);

	if (config.derivative && config.animateTangent) {
		const tangent = svg.appendChild(createSvgElem("line", [["class", "tangent"]]));
		const radial = svg.appendChild(createSvgElem("line", [["class", "radial"]]));
		const tangentAngle = svg.appendChild(createSvgElem("path", [["class", "tangentAngle"]]));
		const textNode = document.getElementById("textnode").firstChild;

		let i = 0;
		const n = numPoints - 1;
		const {step = 4, delay = 100} = config.animateTangent;
		const update = function(oneFrame, reverse) {
			let done = false;
			if (reverse) {
				if (i - step > 0) i -= step; else i = 0;
			} else
				if (i + step < n) i += step;
			else {
				i = n; if (!oneFrame && !reverse) done = true;
			}
			updateTangent(i, config, tangent, radial, tangentAngle, textNode);
			if (done)
				animationEnd();
			else if (!oneFrame)
				animation.timeout = setTimeout(update, delay);
		};
		animationBegin(update);
	}
}
window.addEventListener("DOMContentLoaded", main);
})();
</script>
</head>
<body>
<div id="graph">
<div id="textnode">&nbsp;</div>
</div>
<table>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Logarithmic_spiral">Logarithmic Spirals</a></th></tr>
<tr>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4">r = 40*phi^(theta/(2pi))</a></td>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4&anim=,">O</a>
/   <a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>growthFactor = phi, growthAngle = 2pi</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4">r = 40*e^(theta*tan(6pi/180))</a></td>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4&anim=,">O</a>
/   <a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>slopeAngle = 6&deg;</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4">r = 40*e^(theta/tan(84pi/180))</a></td>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4&anim=,">O</a>
/   <a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>tangentAngle = 84&deg;</td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Rose_(mathematics)">Roses</a></th></tr>
<tr>
<td><a href="polar.html?rose=,4/9&theta=,18pi,pi/180">r = 200*cos(4/9*theta)</a></td>
<td><a href="polar.html?rose=,4/9&theta=,18pi,pi/180&anim=32,">O</a>
/   <a href="polar.html?rose=,4/9&theta=,18pi,pi/180&animtan=,">X</a></td>
<td>0 - 18pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,5,60&theta=,2pi,pi/180">r = 200*cos(5*theta) + 60</a></td>
<td><a href="polar.html?rose=,5,60&theta=,2pi,pi/180&anim=,">O</a>
/   <a href="polar.html?rose=,5,60&theta=,2pi,pi/180&animtan=1,">X</a></td>
<td>0 - 2pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,pi&theta=,32pi,pi/180">r = 200*cos(pi*theta)</a></td>
<td><a href="polar.html?rose=,pi&theta=,32pi,pi/180&anim=16,20">O</a>
/   <a href="polar.html?rose=,pi&theta=,32pi,pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,e&theta=,32pi,pi/180">r = 200*cos(e*theta)</a></td>
<td><a href="polar.html?rose=,e&theta=,32pi,pi/180&anim=16,20">O</a>
/   <a href="polar.html?rose=,e&theta=,32pi,pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=200,1,100&theta=,2pi">r = 200*cos(theta) + 100</a></td>
<td><a href="polar.html?rose=200,1,100&theta=,2pi&anim=,">O</a>
/   <a href="polar.html?rose=200,1,100&theta=,2pi&animtan=,">X</a></td>
<td>0 - 2pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lima%C3%A7on">Lima&ccedil;on</a></td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Archimedean_spiral">Archimedean Spirals</a></th></tr>
<tr>
<td><a href="polar.html?spiral=,12&theta=,8pi">r = 12*theta</a></td>
<td><a href="polar.html?spiral=,12&theta=,8pi&anim=,">O</a>
/   <a href="polar.html?spiral=,12&theta=,8pi&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><a href="polar.html?spiral=,40,2&theta=,16pi">r = 40*sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,40,2&theta=,16pi&anim=,">O</a>
/   <a href="polar.html?spiral=,40,2&theta=,16pi&animtan=,50">X</a></td>
<td>0 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Fermat's_spiral">Fermat's spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi">r = 400/theta</a></td>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&anim=,">O</a>
/   <a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&animtan=,">X</a></td>
<td>pi/4 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Hyperbolic_spiral">Hyperbolic spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi">r = 240/sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&anim=,">O</a>
/   <a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&animtan=,">X</a></td>
<td>pi/12 - 32pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lituus_(mathematics)">Lituus</a></td>
</tr>
<tr><th colspan="4">Morph Demos</th></tr>
<tr>
<td colspan="4">
<a href="polar.html?demo=3">3</a>,
<a href="polar.html?demo=4">4</a>,
<a href="polar.html?demo=5">5</a>,
<a href="polar.html?demo=6">6</a>,
<a href="polar.html?demo=7">7</a>,
<a href="polar.html?demo=8">8</a>
</td>
</tr>
</table>
<svg width="0" height="0">
<defs>
<radialGradient id="gradient1">
	<stop   offset="0.0%" stop-color="#2c7bb6" />
	<stop  offset="12.5%" stop-color="#00a6ca" />
	<stop  offset="25.0%" stop-color="#00ccbc" />
	<stop  offset="37.5%" stop-color="#90eb9d" />
	<stop  offset="50.0%" stop-color="#ffff8c" />
	<stop  offset="62.5%" stop-color="#f9d057" />
	<stop  offset="75.0%" stop-color="#f29e2e" />
	<stop  offset="87.5%" stop-color="#e76818" />
	<stop offset="100.0%" stop-color="#d7191c" />
</radialGradient>
<radialGradient id="gradient2" r="25%" spreadMethod="reflect">
	<stop   offset="0%" stop-color="gold" />
	<stop offset="100%" stop-color="red" />
</radialGradient>
</defs>
</svg>
</body>
</html>
