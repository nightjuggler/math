<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Polar Curve Explorer</title>
<style>
a {
	text-decoration: none;
}
body {
	background-color: white;
	font-family: verdana;
	font-size: 10pt;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}
td,th {
	padding: 2px 4px 2px 4px;
	vertical-align: top;
}
th {
	background-color: rgb(220,220,220);
}
#examples {
	border: 1px solid black;
}
#examples td,
#examples th {
	border: 1px solid black;
}
#formulaParent {
	text-align: center;
}
#graph svg {
	border: 1px solid black;
}
#params {
	width: 200px;
}
#params td:first-child {
	padding-right: 0;
	text-align: right;
	width: 120px;
}
.axis {
	fill: none;
	stroke: black;
	stroke-opacity: 0.3;
	stroke-width: 1px;
}
.curve {
	fill: none;
	stroke: url(#gradient1);
	stroke-width: 2px;
}
.morph {
	display: grid;
	grid-template-columns: repeat(3, max-content);
}
.morph div:nth-child(3n+1) {
	background-color: lavender;
	padding-right: 3px;
	text-align: right;
}
.morph div:nth-child(3n+2) {
	background-color: lavender;
	padding-left: 2px;
	padding-right: 5px;
	text-align: right;
}
.morph div:nth-child(3n) {
	background-color: lavender;
}
.radial {
	stroke: green;
	stroke-width: 2px;
}
.tangent {
	stroke: blue;
	stroke-width: 2px;
}
.tangentAngle {
	fill: none;
	stroke: red;
	stroke-width: 4px;
}
</style>
<script>
/* globals document, window, clearTimeout, setTimeout */
(function() {
"use strict";
const mathConstants = {
	e: Math.E,
	phi: (1 + Math.sqrt(5)) / 2,
	pi: Math.PI,
};
const textNodes = {};
var animation;
function handleKeyDown(event)
{
	if (!animation) return true;

	switch (event.key || event.keyIdentifier) {
		case "ArrowLeft":
		case "Left":
			if (animation.timeout !== null) return true;
			animation.update(true, true);
			break;
		case "ArrowRight":
		case "Right":
			if (animation.timeout !== null) return true;
			animation.update(true);
			break;
		case "U+0020":
		case " ":
			if (animation.timeout !== null) {
				clearTimeout(animation.timeout);
				animation.timeout = null;
			} else
				animation.update();
			break;
		default:
			return true;
	}

	event.preventDefault();
	event.stopPropagation();
	return false;
}
function animationBegin(update)
{
	document.addEventListener("keydown", handleKeyDown);
	animation = {update: update};
	update(false, true);
}
function animationEnd()
{
	document.removeEventListener("keydown", handleKeyDown);
	animation = null;
}
function createSvgElem(tagName, attributes)
{
	const svgNS = "http://www.w3.org/2000/svg";
	const element = document.createElementNS(svgNS, tagName);

	for (const [name, value] of attributes)
		element.setAttribute(name, value);

	return element;
}
function createSvg(width, height)
{
	const centerX = Math.floor(width / 2);
	const centerY = Math.floor(height / 2);

	const svg = document.getElementById("graph")
		.appendChild(createSvgElem("svg", [["width", width], ["height", height]]))
		.appendChild(createSvgElem("g", [["transform", "translate(" + centerX + "," + centerY + ")"]]));

	svg.appendChild(createSvgElem("line", [["class", "axis"],
		["x1", 0], ["y1", centerY],
		["x2", 0], ["y2", -centerY]]));
	svg.appendChild(createSvgElem("line", [["class", "axis"],
		["x1", -centerX], ["y1", 0],
		["x2", centerX], ["y2", 0]]));

	return svg;
}
function parseAnimate(q, v, propName)
{
	const m = v.match(/^([1-9][0-9]{0,2})?,([1-9][0-9]{1,3})?$/);
	if (m === null) return;
	const [, step, delay] = m;
	const animate = {};
	if (step) animate.step = parseInt(step, 10);
	if (delay) animate.delay = parseInt(delay, 10);
	q[propName] = animate;
}
function parseDemo(q, v)
{
	if (v.match(/^[1-9][0-9]?$/) !== null)
		q.demo = parseInt(v, 10);
}
function parseExpr(v)
{
	if (v === "") return null;
	let result = 0;
	for (;;) {
		const m = v.match(/^-?((?:[1-9][0-9]*|0)(?:\.[0-9]+)?)?(e|phi|pi)?(?:\/([1-9][0-9]*))?/);
		if (m === null) return null;
		const [s, a, b, c] = m;
		if (!(a || b)) return null;
		let x = a ? Number(a) : 1;
		if (b) x *= mathConstants[b];
		if (c) x /= Number(c);
		result += s.charAt(0) === "-" ? -x : x;
		v = v.substring(s.length);
		if (v.length === 0) break;
		if (v.charAt(0) === "-") continue;
		if (v.charAt(0) !== "+") return null;
		v = v.substring(1);
	}
	return result;
}
function parseExprList(q, v, propList)
{
	const values = v.split(",");
	const numValues = values.length > propList.length ? propList.length : values.length;

	for (let i = 0; i < numValues; i += 1)
		if ((v = parseExpr(values[i])) !== null) q[propList[i]] = v;
}
function parseMorph(q, v)
{
	v = v.split(",");
	if (v.length < 3) return;
	const [steps, delay, ...props] = v;
	if (/^[1-9][0-9]{0,3}$/.test(steps)) q.morphSteps = parseInt(steps, 10);
	else if (steps !== "") return;
	if (/^[1-9][0-9]{1,3}$/.test(delay)) q.morphDelay = parseInt(delay, 10);
	else if (delay !== "") return;

	const morph = [];
	for (v of props) {
		v = v.split(":");
		if (v.length !== 3) return;
		let [prop, minValue, maxValue] = v;
		if (!/^[a-z][A-Za-z]*$/.test(prop)) return;
		if ((minValue = parseExpr(minValue)) === null) return;
		if ((maxValue = parseExpr(maxValue)) === null) return;
		morph.push([prop, minValue, maxValue]);
	}
	q.morph = morph;
}
function parsePoints(q, v)
{
	if (/^[1-9][0-9]{0,5}$/.test(v))
		q.numPoints = parseInt(v, 10);
}
function parseStroke(q, v)
{
	const m = v.match(/^(?:([A-Za-z]+)|(gradient[1-9]))?(?:,([1-9][0-9]?))?$/);
	if (m === null) return;

	let [, color, gradient, width] = m;
	if (gradient)
		color = "url(#" + gradient + ")";
	if (width)
		width += "px";

	for (const rule of document.styleSheets[0].cssRules)
		if (rule.selectorText === ".curve") {
			if (color)
				rule.style.setProperty("stroke", color);
			if (width)
				rule.style.setProperty("stroke-width", width);
			break;
		}
}
function isValidId(s, n)
{
	return s.length <= n && s.match(/^[a-z][_0-9a-z]*$/) !== null;
}
function parseQueryString(params, handlers, flags)
{
	const q = window.location.search;

	if (typeof q !== 'string' || q.charAt(0) !== '?') return;

	if (!flags) flags = {};
	if (!handlers) handlers = {};

	for (const s of q.substr(1).split('&'))
	{
		const i = s.indexOf('=');
		if (i < 0 && isValidId(s, 6) && flags[s]) {
			params[flags[s]] = true;
			continue;
		}
		if (i < 1 || i === s.length - 1) continue;
		const k = s.substr(0, i);
		const v = s.substr(i + 1);

		if (isValidId(k, 12) && handlers[k])
			handlers[k](params, v);
	}
}
function setTextNodes()
{
	for (const id of [
		"formula",
		"theta",
		"radius",
		"thetaStart",
		"thetaEnd",
		"thetaStep",
		"numPoints",
		"slopeAngle",
		"tangentAngle",
		"growthFactor",
		"growthAngle",
		])
		textNodes[id] = document.getElementById(id).firstChild;
}
function removeTextRow(textNode)
{
	const tr = textNode.parentNode.parentNode.parentNode;
	tr.parentNode.removeChild(tr);
}
function setFormula(formula)
{
	textNodes.formula.nodeValue = formula;
}
const regEx = /\.?0+$/;
const toStr = n => Number.isInteger(n) ? n : n.toFixed(6).replace(regEx, "");
const toStr2 = n => Number.isInteger(n) ? n : n.toFixed(2).replace(regEx, "");
function logSpiralFormula1(a, b)
{
	return (a === 1 ? "" : toStr(a) + " * ") + "e ^ (theta * tan(" + toStr(b) + "))";
}
function logSpiralFormula2(a, b)
{
	return (a === 1 ? "" : toStr(a) + " * ") + "e ^ (theta / tan(" + toStr(b) + "))";
}
function logSpiralFormula3(a, b, c)
{
	return (a === 1 ? "" : toStr(a) + " * ") + toStr(b) + " ^ (theta / " + toStr(c) + ")";
}
function roseFormula(a, b, c)
{
	let formula = "";
	if (a !== 1) formula += toStr(a) + " * ";
	formula += "cos(";
	if (b !== 1) formula += toStr(b) + " * ";
	formula += "theta)";
	if (c !== 0) formula += c < 0 ? " - " + toStr(-c) : " + " + toStr(c);
	return formula;
}
function spiralFormula(a, b, c)
{
	let formula = "";
	if (a !== 0) formula += toStr(a) + " + ";
	if (b !== 1) formula += toStr(b) + " * ";
	formula += "theta";
	if (c !== 1) formula += " ^ (1 / " + toStr(c) + ")";
	return formula;
}
function setRadialPath(path, data)
{
	let m = true;
	path.setAttribute("d", Array.from(data, ([t, r]) => Number.isNaN(r) ? (m = true, "") :
		(m ? (m = false, "M") : "L") +
		( r * Math.cos(t)).toFixed(2) + "," +
		(-r * Math.sin(t)).toFixed(2)).join(""));
}
function updateTangent(i, config, tangent, radial, arcPath)
{
/*
	The slope m of the line tangent to the curve r = f(t) at point (r, t) is

	m = dy/dx = ( (dr/dt)*sin(t) + r*cos(t) ) / ( (dr/dt)*cos(t) - r*sin(t) )
*/
	const {theta, radius, derivative} = config;
	const t = theta(i);
	const r = radius(i);

	if (Number.isNaN(r)) {
		tangent.removeAttribute("x1");
		tangent.removeAttribute("y1");
		tangent.removeAttribute("x2");
		tangent.removeAttribute("y2");
		radial.removeAttribute("x2");
		radial.removeAttribute("y2");
		arcPath.removeAttribute("d");

		textNodes.theta.nodeValue = toStr2(t * 180 / Math.PI);
		textNodes.radius.nodeValue = "NaN";
		textNodes.slopeAngle.nodeValue = "NaN";
		textNodes.tangentAngle.nodeValue = "NaN";
		return;
	}

	const drdt = derivative(i);
	const sin = Math.sin(t);
	const cos = Math.cos(t);
	const x = r * cos;
	const y = r * sin;
	const m = (drdt * sin + x) / (drdt * cos - y);
/*
	The tangent of the slope angle a of the tangent line is the slope m: tan(a) = m

	To move a distance h along the tangent line, calculate dx and dy:

	dx = h * cos(a) = h / sqrt(1 + tan(a)*tan(a)) = h / sqrt(1 + m*m)
	dy = h * sin(a) = h * tan(a) / sqrt(1 + tan(a)*tan(a)) = tan(a) * dx = m * dx
*/
	const h = 200;
	const dx = h / Math.sqrt(1 + m * m);
	const dy = dx === 0 ? h : m * dx;

	tangent.setAttribute("x1", x + dx);
	tangent.setAttribute("y1", -(y + dy));
	tangent.setAttribute("x2", x - dx);
	tangent.setAttribute("y2", -(y - dy));
	radial.setAttribute("x2", x);
	radial.setAttribute("y2", -y);

	const arcRadius = 20;
	if (r > arcRadius) {
		const arcX1 = (r - arcRadius) * cos;
		const arcY1 = (r - arcRadius) * sin;
		let arcDx = arcRadius / Math.sqrt(1 + m * m);
		let arcDy = arcDx === 0 ? arcRadius : m * arcDx;

		if (m > 0 ? drdt < 0 ? sin <= 0 : cos > 0 : drdt < 0 ? cos <= 0 : sin <= 0) {
			arcDy = -arcDy;
			arcDx = -arcDx;
		}

		arcPath.setAttribute("d", [
			"M", arcX1, -arcY1,
			"A", arcRadius, arcRadius, 0, 0, 0, x + arcDx, -(y + arcDy),
		].join(" "));
	} else
		arcPath.setAttribute("d", "");
/*
	The tangent of the tangent angle psi of the curve r = f(t) at point (r, t) is

	tan(psi) = r / (dr/dt)

	The tangent angle is the angle between the radial line from the origin to the point (r, t)
	and the line tangent to the curve at point (r, t).

	The slope angle of the curve at point (r, t) is pi/2 - psi
*/
	const tangentAngle = Math.atan2(r, drdt) * 180 / Math.PI;

	textNodes.theta.nodeValue = toStr2(t * 180 / Math.PI);
	textNodes.radius.nodeValue = toStr2(r);
	textNodes.slopeAngle.nodeValue = toStr2(90 - tangentAngle);
	textNodes.tangentAngle.nodeValue = toStr2(tangentAngle);
}
function setAngle(config)
{
	let {thetaStart, thetaEnd, thetaStep, numPoints} = config;

	if (typeof thetaStart !== "number")
		thetaStart = 0;

	if (typeof thetaEnd === "number" && thetaStart < thetaEnd) {
		if (typeof thetaStep === "number" && thetaStep > 0)
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		else if (typeof numPoints === "number" && numPoints > 1)
			thetaStep = (thetaEnd - thetaStart) / (numPoints - 1);
		else {
			thetaStep = Math.PI / 180; // 1 degree;
			numPoints = (thetaEnd - thetaStart) / thetaStep + 1;
		}
		if (!Number.isInteger(numPoints)) {
			numPoints = Math.ceil(numPoints);
			thetaStep = (thetaEnd - thetaStart) / (numPoints - 1);
		}
		textNodes.thetaEnd.nodeValue = toStr2(thetaEnd * 180 / Math.PI) + "\u00B0";
	} else {
		if (!(typeof thetaStep === "number" && thetaStep > 0))
			thetaStep = Math.PI / 180; // 1 degree;
		if (!(typeof numPoints === "number" && numPoints > 1))
			numPoints = 12*360 + 1;
		textNodes.thetaEnd.nodeValue = "none";
	}

	config.theta = i => thetaStart + i * thetaStep;
	config.numPoints = numPoints;

	textNodes.thetaStart.nodeValue = toStr2(thetaStart * 180 / Math.PI);
	textNodes.thetaStep.nodeValue = toStr2(thetaStep * 180 / Math.PI);
	textNodes.numPoints.nodeValue = toStr2(numPoints);

	return config.theta;
}
function logSpiral(config)
{
	const theta = setAngle(config);

	let {initialRadius, slopeAngle, tangentAngle, growthFactor, growthAngle} = config;

	if (!(typeof initialRadius === "number" && initialRadius !== 0))
		initialRadius = 40;
	if (!(typeof growthFactor === "number" && growthFactor > 0))
		growthFactor = 1.5;
	if (!(typeof growthAngle === "number" && growthAngle > 0))
		growthAngle = Math.PI; // 180 degrees

	if (typeof slopeAngle === "number") {

		const k = Math.tan(slopeAngle);
		const radius = i => initialRadius * Math.exp(k * theta(i));
		config.radius = radius;
		config.derivative = i => k * radius(i);
		setFormula(logSpiralFormula1(initialRadius, slopeAngle));
		growthFactor = Math.exp(k * growthAngle);
		tangentAngle = Math.PI / 2 - slopeAngle;

	} else if (typeof tangentAngle === "number" && tangentAngle !== 0) {

		const k = 1 / Math.tan(tangentAngle);
		const radius = i => initialRadius * Math.exp(k * theta(i));
		config.radius = radius;
		config.derivative = i => k * radius(i);
		setFormula(logSpiralFormula2(initialRadius, tangentAngle));
		growthFactor = Math.exp(k * growthAngle);
		slopeAngle = Math.PI / 2 - tangentAngle;

	} else {
		const k = Math.log(growthFactor) / growthAngle;
		const radius = i => initialRadius * Math.pow(growthFactor, theta(i) / growthAngle);
		config.radius = radius;
		config.derivative = i => k * radius(i);
		setFormula(logSpiralFormula3(initialRadius, growthFactor, growthAngle));
		slopeAngle = Math.atan2(Math.log(growthFactor), growthAngle);
		tangentAngle = Math.PI / 2 - slopeAngle;
	}

	textNodes.slopeAngle.nodeValue = toStr2(slopeAngle * 180 / Math.PI);
	textNodes.tangentAngle.nodeValue = toStr2(tangentAngle * 180 / Math.PI);
	textNodes.growthFactor.nodeValue = toStr(growthFactor);
	textNodes.growthAngle.nodeValue = toStr2(growthAngle * 180 / Math.PI);

	config.grid = function(svg) {
		for (let i = 0; i < 6; i += 1)
			svg.appendChild(createSvgElem("circle", [["class", "axis"], ["cx", 0], ["cy", 0],
				["r", initialRadius * Math.pow(growthFactor, i)]]));
	};
	return config;
}
function roseCurve(config)
{
	const theta = setAngle(config);

	let {scale, k, offset} = config;

	if (!(typeof scale === "number" && scale > 0))
		scale = 200;
	if (typeof k !== "number")
		k = 4 / 9;
	if (typeof offset !== "number")
		offset = 0;

	config.radius = i => scale * Math.cos(k * theta(i)) + offset;
	config.derivative = i => scale * k * -Math.sin(k * theta(i));
	setFormula(roseFormula(scale, k, offset));

	config.grid = function(svg) {
		svg.appendChild(createSvgElem("circle", [["class", "axis"], ["cx", 0], ["cy", 0], ["r", scale]]));
	};
	return config;
}
function spiral(config)
{
	const theta = setAngle(config);

	let {a, b, c} = config;

	if (typeof a !== "number") a = 0;
	if (typeof b !== "number") b = 12;
	if (typeof c !== "number" || c === 0) c = 1;

	if (c === 1) {
		config.radius = i => a + b * theta(i);
		config.derivative = i => b;
	} else {
		config.radius = i => a + b * Math.pow(theta(i), 1 / c);
		config.derivative = i => b * Math.pow(theta(i), 1 / c - 1) / c;
	}
	setFormula(spiralFormula(a, b, c));
	return config;
}
function sinSpiral(config)
{
	const theta = setAngle(config);
	let {a, n, b} = config;

	if (typeof a !== "number") a = 1;
	if (typeof n !== "number" || n === 0) n = 1;
	if (typeof b !== "number") b = 0;

	config.radius = i => a * Math.pow(Math.cos(n * theta(i)), 1 / n) + b;
	config.derivative = i => {
		const t = theta(i);
		return -a * Math.sin(n * t) * Math.pow(Math.cos(n * t), 1 / n - 1);
	};

	const nStr = toStr(n);
	setFormula(toStr(a) + " * cos(" + nStr + " * theta) ^ (1 / " + nStr + ")" +
		(b === 0 ? "" : " + " + toStr(b)));
	return config;
}
const unnamedCurves = {
"a*sin(b*t)*t+c": [["a", "b", "c"],
function(config) {
	const theta = setAngle(config);
	let {a, b, c} = config;

	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 0;

	config.radius = i => {
		const t = theta(i);
		return a * Math.sin(b * t) * t + c;
	};

	setFormula(toStr(a) + " * sin(" + toStr(b) + " * theta) * theta" + (c === 0 ? "" : " + " + toStr(c)));
	return config;
}],
"a*sin(b*t)/t+c": [["a", "b", "c"],
function(config) {
	const theta = setAngle(config);
	let {a, b, c} = config;

	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 0;

	config.radius = i => {
		const t = theta(i);
		return a * Math.sin(b * t) / t + c;
	};

	setFormula(toStr(a) + " * sin(" + toStr(b) + " * theta) / theta" + (c === 0 ? "" : " + " + toStr(c)));
	return config;
}],
"a*sin(b*t)*cos(c*t)+d": [["a", "b", "c", "d"],
function(config) {
	const theta = setAngle(config);
	let {a, b, c, d} = config;

	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 1;
	if (typeof d !== "number") d = 0;

	config.radius = i => {
		const t = theta(i);
		return a * Math.sin(b * t) * Math.cos(c * t) + d;
	};

	setFormula(toStr(a) + " * sin(" + toStr(b) + " * theta) * cos(" + toStr(c) + " * theta)" +
		(d === 0 ? "" : " + " + toStr(d)));
	return config;
}],
"a*t+b*cos(c*t)+d": [["a", "b", "c", "d"],
function(config) {
	const theta = setAngle(config);
	let {a, b, c, d} = config;

	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 1;
	if (typeof d !== "number") d = 0;

	config.radius = i => {
		const t = theta(i);
		return a * t + b * Math.cos(c * t) + d;
	};

	setFormula(`${toStr(a)} * theta + ${toStr(b)} * cos(${toStr(c)} * theta) + ${toStr(d)}`);
	return config;
}],
"a*t+b*sin(bt*t)+c*cos(ct*t)+d": [["a", "b", "c", "d", "bt", "ct"],
function(config) {
	const theta = setAngle(config);
	let {a, b, c, d, bt, ct} = config;

	if (typeof a !== "number") a = 1;
	if (typeof b !== "number") b = 1;
	if (typeof c !== "number") c = 1;
	if (typeof d !== "number") d = 0;
	if (typeof bt !== "number") bt = 2 * Math.PI;
	if (typeof ct !== "number") ct = 2 * Math.PI;

	config.radius = i => {
		const t = theta(i);
		return a * t + b * Math.sin(bt * t) + c * Math.cos(ct * t) + d;
	};

	setFormula(`${toStr(a)} * theta + ${toStr(b)} * sin(${toStr(bt)} * theta) + ${toStr(c)} * cos(${toStr(ct)} * theta) + ${toStr(d)}`);
	return config;
}],
};
function parseUnnamedCurve(q, v)
{
	const i = v.indexOf(",");
	const curve = unnamedCurves[i < 0 ? v : v.substring(0, i)];
	if (!curve) return;
	q.curve = curve[1];
	if (i >= 0)
		parseExprList(q, v.substring(i + 1), curve[0]);
}
function morph(config, svg)
{
	const props = config.morph;
	const delay = config.morphDelay || 100;
	const steps = config.morphSteps || 100;

	for (const p of props) {
		const [prop, minValue, maxValue] = p;
		config[prop] = minValue;
		p.push((maxValue - minValue) / steps);
	}
	const path = svg.appendChild(createSvgElem("path", [["class", "curve"]]));

	const update = function(oneFrame, reverse) {
		let done = !oneFrame && !reverse;
		for (const [prop, minValue, maxValue, step] of props)
			if (reverse) {
				const nextValue = config[prop] - step;
				if (step < 0 ? nextValue < minValue : nextValue > minValue)
					config[prop] = nextValue;
				else
					config[prop] = minValue;
			} else {
				const nextValue = config[prop] + step;
				if (step < 0 ? nextValue > maxValue : nextValue < maxValue) {
					done = false;
					config[prop] = nextValue;
				} else
					config[prop] = maxValue;
			}

		const {numPoints, theta, radius} = config.curve(config);
		const data = Array.from({length: numPoints}, (v, i) => [theta(i), radius(i)]);
		setRadialPath(path, data);
		if (done)
			animationEnd();
		else if (!oneFrame)
			animation.timeout = setTimeout(update, delay);
	};
	animationBegin(update);
}
function predefinedConfig(i)
{
	const growthFactor = mathConstants.phi;
	const growthAngle = 2 * Math.PI;
	const configs = [
		{// demo=1
			curve: logSpiral,
			slopeAngle: Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		},
		{// demo=2
			curve: logSpiral,
			tangentAngle: Math.PI / 2 - Math.atan2(Math.log(growthFactor), growthAngle),
			growthAngle: growthAngle,
			thetaEnd: 8 * Math.PI,
		},
	];
	return i >= 0 && i < configs.length ? configs[i] : {};
}
function main()
{
	setTextNodes();

	let config = {};
	parseQueryString(config, {
		anim: function(q, v) {
			parseAnimate(q, v, "animate");
		},
		animtan: function(q, v) {
			parseAnimate(q, v, "animateTangent");
		},
		demo: parseDemo,
		logspiral: function(q, v) {
			q.curve = logSpiral;
			parseExprList(q, v, ["initialRadius", "slopeAngle", "tangentAngle",
				"growthFactor", "growthAngle"]);
		},
		morph: parseMorph,
		points: parsePoints,
		r: parseUnnamedCurve,
		rose: function(q, v) {
			q.curve = roseCurve;
			parseExprList(q, v, ["scale", "k", "offset"]);
		},
		sinspiral: function(q, v) {
			q.curve = sinSpiral;
			parseExprList(q, v, ["a", "n", "b"]);
		},
		spiral: function(q, v) {
			q.curve = spiral;
			parseExprList(q, v, ["a", "b", "c"]);
		},
		stroke: parseStroke,
		theta: function(q, v) {
			parseExprList(q, v, ["thetaStart", "thetaEnd", "thetaStep"]);
		},
	}, {});

	if (config.demo)
		config = predefinedConfig(config.demo - 1);
	if (!config.curve)
		config.curve = roseCurve;
	if (config.curve !== logSpiral) {
		removeTextRow(textNodes.growthFactor);
		removeTextRow(textNodes.growthAngle);
	}

	const svg = createSvg(900, 680);

	if (config.morph) {
		removeTextRow(textNodes.theta);
		removeTextRow(textNodes.radius);
		if (config.curve !== logSpiral) {
			removeTextRow(textNodes.slopeAngle);
			removeTextRow(textNodes.tangentAngle);
		}
		morph(config, svg);
		return;
	}

	const {numPoints, theta, radius} = config.curve(config);
	const data = Array.from({length: numPoints}, (v, i) => [theta(i), radius(i)]);

	if (config.grid)
		config.grid(svg);

	const path = svg.appendChild(createSvgElem("path", [["class", "curve"]]));
	const animateTangent = config.animateTangent && config.derivative;

	if (config.animate) {
		let i = 0;
		const {step = 8, delay = 50} = config.animate;
		const update = function() {
			const dataSlice = data.slice(0, i += step);
			setRadialPath(path, dataSlice);
			if (!animateTangent) {
				const [t, r] = dataSlice[dataSlice.length - 1];
				textNodes.theta.nodeValue = toStr2(t * 180 / Math.PI);
				textNodes.radius.nodeValue = toStr2(r);
			}
			if (i < numPoints)
				setTimeout(update, delay);
		};
		update();
	} else {
		setRadialPath(path, data);
		if (!animateTangent) {
			const [t, r] = data[numPoints - 1];
			textNodes.theta.nodeValue = toStr2(t * 180 / Math.PI);
			textNodes.radius.nodeValue = toStr2(r);
		}
	}

	if (animateTangent) {
		const tangent = svg.appendChild(createSvgElem("line", [["class", "tangent"]]));
		const radial = svg.appendChild(createSvgElem("line", [["class", "radial"]]));
		const tangentAngle = svg.appendChild(createSvgElem("path", [["class", "tangentAngle"]]));

		let i = 0;
		const n = numPoints - 1;
		const {step = 4, delay = 100} = config.animateTangent;
		const update = function(oneFrame, reverse) {
			let done = false;
			if (reverse) {
				if (i - step > 0) i -= step; else i = 0;
			} else
				if (i + step < n) i += step;
			else {
				i = n; if (!oneFrame && !reverse) done = true;
			}
			updateTangent(i, config, tangent, radial, tangentAngle);
			if (done)
				animationEnd();
			else if (!oneFrame)
				animation.timeout = setTimeout(update, delay);
		};
		animationBegin(update);
	}
	else if (config.curve !== logSpiral) {
		removeTextRow(textNodes.slopeAngle);
		removeTextRow(textNodes.tangentAngle);
	}
}
window.addEventListener("DOMContentLoaded", main);
})();
</script>
</head>
<body>
<table id="layout">
<tr>
<td>&nbsp;</td>
<td id="formulaParent">radius = <span id="formula">&nbsp;</span></td>
</tr>
<tr>
<td><table id="params">
<tr><td>       theta =</td><td><span id="theta">&nbsp;</span>&deg;</td></tr>
<tr><td>      radius =</td><td><span id="radius">&nbsp;</span></td></tr>
<tr><td>  thetaStart =</td><td><span id="thetaStart">&nbsp;</span>&deg;</td></tr>
<tr><td>    thetaEnd =</td><td><span id="thetaEnd">&nbsp;</span></td></tr>
<tr><td>   thetaStep =</td><td><span id="thetaStep">&nbsp;</span>&deg;</td></tr>
<tr><td>   numPoints =</td><td><span id="numPoints">&nbsp;</span></td></tr>
<tr><td>  slopeAngle =</td><td><span id="slopeAngle">&nbsp;</span>&deg;</td></tr>
<tr><td>tangentAngle =</td><td><span id="tangentAngle">&nbsp;</span>&deg;</td></tr>
<tr><td>growthFactor =</td><td><span id="growthFactor">&nbsp;</span></td></tr>
<tr><td> growthAngle =</td><td><span id="growthAngle">&nbsp;</span>&deg;</td></tr>
</table></td>
<td id="graph"></td>
</tr>
<tr>
<td>&nbsp;</td>
<td><table id="examples">
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Logarithmic_spiral">Logarithmic Spirals</a></th></tr>
<tr>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4">r = 40*phi^(theta/(2pi))</a></td>
<td><a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4&anim=,">O</a>
/   <a href="polar.html?logspiral=,,,phi,2pi&theta=,8pi&stroke=magenta,4&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>growthFactor = phi
<br>growthAngle = 2pi</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4">r = 40*e^(theta*tan(6pi/180))</a></td>
<td><a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4&anim=,">O</a>
/   <a href="polar.html?logspiral=,6pi/180&theta=,8pi&stroke=,4&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>slopeAngle = 6&deg;</td>
</tr>
<tr>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4">r = 40*e^(theta/tan(84pi/180))</a></td>
<td><a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4&anim=,">O</a>
/   <a href="polar.html?logspiral=,,84pi/180&theta=,8pi&stroke=,4&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>tangentAngle = 84&deg;</td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Rose_(mathematics)">Roses</a></th></tr>
<tr>
<td><a href="polar.html?rose=,4/9&theta=,18pi,pi/180">r = 200*cos(4/9*theta)</a></td>
<td><a href="polar.html?rose=,4/9&theta=,18pi,pi/180&anim=32,">O</a>
/   <a href="polar.html?rose=,4/9&theta=,18pi,pi/180&animtan=,">X</a></td>
<td>0 - 18pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,5,60&theta=,2pi,pi/180">r = 200*cos(5*theta) + 60</a></td>
<td><a href="polar.html?rose=,5,60&theta=,2pi,pi/180&anim=,">O</a>
/   <a href="polar.html?rose=,5,60&theta=,2pi,pi/180&animtan=1,">X</a></td>
<td>0 - 2pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,pi&theta=,32pi,pi/180">r = 200*cos(pi*theta)</a></td>
<td><a href="polar.html?rose=,pi&theta=,32pi,pi/180&anim=16,20">O</a>
/   <a href="polar.html?rose=,pi&theta=,32pi,pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=,e&theta=,32pi,pi/180">r = 200*cos(e*theta)</a></td>
<td><a href="polar.html?rose=,e&theta=,32pi,pi/180&anim=16,20">O</a>
/   <a href="polar.html?rose=,e&theta=,32pi,pi/180&animtan=,">X</a></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?rose=200,1,100&theta=,2pi">r = 200*cos(theta) + 100</a></td>
<td><a href="polar.html?rose=200,1,100&theta=,2pi&anim=,">O</a>
/   <a href="polar.html?rose=200,1,100&theta=,2pi&animtan=,">X</a></td>
<td>0 - 2pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lima%C3%A7on">Lima&ccedil;on</a></td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Archimedean_spiral">Archimedean Spirals</a></th></tr>
<tr>
<td><a href="polar.html?spiral=,12&theta=,8pi">r = 12*theta</a></td>
<td><a href="polar.html?spiral=,12&theta=,8pi&anim=,">O</a>
/   <a href="polar.html?spiral=,12&theta=,8pi&animtan=,">X</a></td>
<td>0 - 8pi</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><a href="polar.html?spiral=,40,2&theta=,16pi">r = 40*sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,40,2&theta=,16pi&anim=,">O</a>
/   <a href="polar.html?spiral=,40,2&theta=,16pi&animtan=,50">X</a></td>
<td>0 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Fermat's_spiral">Fermat's spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi">r = 400/theta</a></td>
<td><a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&anim=,">O</a>
/   <a href="polar.html?spiral=,400,-1&theta=pi/4,16pi&animtan=,">X</a></td>
<td>pi/4 - 16pi</td>
<td><a href="https://en.wikipedia.org/wiki/Hyperbolic_spiral">Hyperbolic spiral</a></td>
</tr>
<tr>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi">r = 240/sqrt(theta)</a></td>
<td><a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&anim=,">O</a>
/   <a href="polar.html?spiral=,240,-2&theta=pi/12,32pi&animtan=,">X</a></td>
<td>pi/12 - 32pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lituus_(mathematics)">Lituus</a></td>
</tr>
<tr><th colspan="4"><a href="https://en.wikipedia.org/wiki/Sinusoidal_spiral">Sinusoidal Spirals</a></th></tr>
<tr>
<td><a href="polar.html?sinspiral=10,-1/3&theta=-5pi/4,5pi/4,pi/360">r = 10/cos(&minus;theta/3)^3</a></td>
<td><a href="polar.html?sinspiral=10,-1/3&theta=-5pi/4,5pi/4,pi/360&anim=,">O</a>
/   <a href="polar.html?sinspiral=10,-1/3&theta=-5pi/4,5pi/4,pi/360&animtan=,">X</a></td>
<td>&minus;5pi/4 - 5pi/4</td>
<td><a href="https://en.wikipedia.org/wiki/Tschirnhausen_cubic">Tschirnhausen cubic</a>
<br>thetaStep = 0.5&deg;</td>
</tr>
<tr>
<td><a href="polar.html?sinspiral=400,1/3&theta=0,3pi,pi/180">r = 400*cos(theta/3)^3</a></td>
<td><a href="polar.html?sinspiral=400,1/3&theta=0,3pi,pi/180&anim=,">O</a>
/   <a href="polar.html?sinspiral=400,1/3&theta=0,3pi,pi/180&animtan=,">X</a></td>
<td>0 - 3pi</td>
<td><a href="https://en.wikipedia.org/wiki/Cayley%27s_sextic">Cayley's sextic</a>
<br>thetaStep = 1&deg;</td>
</tr>
<tr>
<td><a href="polar.html?sinspiral=400,2&theta=0,2pi,pi/18000">r = 400*sqrt(cos(2*theta))</a></td>
<td><a href="polar.html?sinspiral=400,2&theta=0,2pi,pi/18000&anim=200,">O</a>
/   <a href="polar.html?sinspiral=400,2&theta=0,2pi,pi/18000&animtan=100,">X</a></td>
<td>0 - 2pi</td>
<td><a href="https://en.wikipedia.org/wiki/Lemniscate_of_Bernoulli">Lemniscate of Bernoulli</a>
<br>thetaStep = 0.01&deg;</td>
</tr>
<tr><th colspan="4">Other Curves</th></tr>
<tr>
<td><a href="polar.html?r=a*sin(b*t)/t+c,400&theta=-12pi,12pi,pi/720">r = 400*sin(theta)/theta</a></td>
<td></td>
<td>&minus;12pi - 12pi</td>
<td><a href="https://en.wikipedia.org/wiki/Cochleoid">Cochleoid</a>
<br>thetaStep = 0.25&deg;</td>
</tr>
<tr>
<td><a href="polar.html?r=a*t+b*cos(c*t)+d,4,56,3e,56&theta=0,16pi,pi/180">r = 4*theta + 56*cos(3*e*theta) + 56</a></td>
<td></td>
<td>0 - 16pi</td>
<td>thetaStep = 1&deg;</td>
</tr>
<tr><th colspan="4">Morph Demos</th></tr>
<tr>
<td colspan="2"><a href="polar.html?rose=,&morph=200,100,scale:100:300,k:e:e+2,offset:-100:100&theta=,32pi,pi/180">r = scale * cos(k*theta) + offset</a>
<div class="morph">
<div>     k =</div><div>         e &rarr;</div><div>e+2</div>
<div> scale =</div><div>       100 &rarr;</div><div>300</div>
<div>offset =</div><div>&minus;100 &rarr;</div><div>100</div>
</div></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 200
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?rose=100,4/9&morph=440,20,offset:-220:220&theta=,18pi,pi/180">r = 100 * cos(4/9 * theta) + offset</a>
<div class="morph">
<div>offset =</div><div>&minus;220 &rarr;</div><div>220</div>
</div></td>
<td>0 - 18pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 440
<br>morphDelay = 20ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?rose=100,5&morph=500,20,offset:-250:250&theta=,2pi,pi/180">r = 100 * cos(5 * theta) + offset</a>
<div class="morph">
<div>offset =</div><div>&minus;250 &rarr;</div><div>250</div>
</div></td>
<td>0 - 2pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 500
<br>morphDelay = 20ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?rose=,,0&morph=200,200,scale:200:340,k:pi-1:pi+1&theta=,32pi,pi/180">r = scale * cos(k * theta)</a>
<div class="morph">
<div>    k =</div><div>pi&minus;1 &rarr;</div><div>pi+1</div>
<div>scale =</div><div>         200 &rarr;</div><div>   340</div>
</div></td>
<td>0 - 32pi</td>
<td>thetaStep = 1&deg;
<br>morphSteps = 200
<br>morphDelay = 200ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?spiral=,10&morph=130,200,numPoints:20:280&theta=,16pi">r = 10 * theta</a></td>
<td>0 - 16pi</td>
<td><div class="morph">
<div>numPoints =</div><div>20 &rarr;</div><div>280</div>
</div>
morphSteps = 130
<br>morphDelay = 200ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?spiral=,6&morph=179,100,thetaStep:pi/360:pi/2&points=80">r = 6 * theta</a></td>
<td>&nbsp;</td>
<td><div class="morph">
<div>thetaStep =</div><div>pi/360 &rarr;</div><div>pi/2</div>
</div>
numPoints = 80
<br>morphSteps = 179
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?spiral=,6&morph=180,100,thetaStep:pi/2:pi&points=120">r = 6 * theta</a></td>
<td>&nbsp;</td>
<td><div class="morph">
<div>thetaStep =</div><div>pi/2 &rarr;</div><div>pi</div>
</div>
numPoints = 120
<br>morphSteps = 180
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*sin(b*t)*t+c,9&theta=0,12pi&morph=200,150,b:1:17,c:0:17">r = 9*sin(b*theta)*theta + c</a>
<div class="morph">
<div>b =</div><div>1 &rarr;</div><div>17</div>
<div>c =</div><div>0 &rarr;</div><div>17</div>
</div></td>
<td>0 - 12pi</td>
<td>morphSteps = 200
<br>morphDelay = 150ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*sin(b*t)*cos(c*t)+d,-200,1,1,0&theta=0,12pi,pi/360&morph=100,100,b:0:20,d:220:20">r = &minus;200*sin(b*theta)*cos(theta) + d</a>
<div class="morph">
<div>b =</div><div>0 &rarr;</div><div>20</div>
<div>d =</div><div>220 &rarr;</div><div>20</div>
</div></td>
<td>0 - 12pi</td>
<td>thetaStep = 0.5&deg;
<br>morphSteps = 100
<br>morphDelay = 100ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,1,1,0,2pi,2pi&theta=0,12pi&morph=90,20,b:1:181,c:181:1">r = 9*theta
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ b*sin(2pi*theta)
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ c*cos(2pi*theta)</a>
<div class="morph">
<div>b =</div><div>1 &rarr;</div><div>181</div>
<div>c =</div><div>181 &rarr;</div><div>1</div>
</div></td>
<td>0 - 12pi</td>
<td>morphSteps = 90
<br>morphDelay = 20ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,36,1,0,2pi,2pi&theta=0,12pi&morph=100,50,c:-360:360">r = 9*theta
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ 36*sin(2pi*theta)
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ c*cos(2pi*theta)</a>
<div class="morph">
<div>c =</div><div>&minus;360 &rarr;</div><div>360</div>
</div></td>
<td>0 - 12pi</td>
<td>morphSteps = 100
<br>morphDelay = 50ms</td>
</tr>
<tr>
<td colspan="2"><a href="polar.html?r=a*t+b*sin(bt*t)+c*cos(ct*t)+d,9,27,-99,0,4,4&theta=0,12pi&morph=100,40,d:-360:120">r = 9*theta
<br>&nbsp;&nbsp;&nbsp;&nbsp;+ 27*sin(4*theta)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&minus; 99*cos(4*theta) + d</a>
<div class="morph">
<div>d =</div><div>&minus;360 &rarr;</div><div>360</div>
</div></td>
<td>0 - 12pi</td>
<td>morphSteps = 100
<br>morphDelay = 40ms</td>
</tr>
</table></td>
</tr>
</table>
<svg width="0" height="0">
<defs>
<radialGradient id="gradient1">
	<stop   offset="0.0%" stop-color="#2c7bb6" />
	<stop  offset="12.5%" stop-color="#00a6ca" />
	<stop  offset="25.0%" stop-color="#00ccbc" />
	<stop  offset="37.5%" stop-color="#90eb9d" />
	<stop  offset="50.0%" stop-color="#ffff8c" />
	<stop  offset="62.5%" stop-color="#f9d057" />
	<stop  offset="75.0%" stop-color="#f29e2e" />
	<stop  offset="87.5%" stop-color="#e76818" />
	<stop offset="100.0%" stop-color="#d7191c" />
</radialGradient>
<radialGradient id="gradient2" r="25%" spreadMethod="reflect">
	<stop   offset="0%" stop-color="gold" />
	<stop offset="100%" stop-color="red" />
</radialGradient>
</defs>
</svg>
</body>
</html>
